
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model TipoAcesso
 * 
 */
export type TipoAcesso = $Result.DefaultSelection<Prisma.$TipoAcessoPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Funcionario
 * 
 */
export type Funcionario = $Result.DefaultSelection<Prisma.$FuncionarioPayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model StatusPedido
 * 
 */
export type StatusPedido = $Result.DefaultSelection<Prisma.$StatusPedidoPayload>
/**
 * Model StatusPagamento
 * 
 */
export type StatusPagamento = $Result.DefaultSelection<Prisma.$StatusPagamentoPayload>
/**
 * Model Cardapio
 * 
 */
export type Cardapio = $Result.DefaultSelection<Prisma.$CardapioPayload>
/**
 * Model ProdutosDoPedido
 * 
 */
export type ProdutosDoPedido = $Result.DefaultSelection<Prisma.$ProdutosDoPedidoPayload>
/**
 * Model Produto
 * 
 */
export type Produto = $Result.DefaultSelection<Prisma.$ProdutoPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>
/**
 * Model CategoriaProduto
 * 
 */
export type CategoriaProduto = $Result.DefaultSelection<Prisma.$CategoriaProdutoPayload>
/**
 * Model ProdutosDoCardapio
 * 
 */
export type ProdutosDoCardapio = $Result.DefaultSelection<Prisma.$ProdutosDoCardapioPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clientes
 * const clientes = await prisma.cliente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clientes
   * const clientes = await prisma.cliente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.tipoAcesso`: Exposes CRUD operations for the **TipoAcesso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoAcessos
    * const tipoAcessos = await prisma.tipoAcesso.findMany()
    * ```
    */
  get tipoAcesso(): Prisma.TipoAcessoDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.funcionario`: Exposes CRUD operations for the **Funcionario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funcionarios
    * const funcionarios = await prisma.funcionario.findMany()
    * ```
    */
  get funcionario(): Prisma.FuncionarioDelegate<ExtArgs>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs>;

  /**
   * `prisma.statusPedido`: Exposes CRUD operations for the **StatusPedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusPedidos
    * const statusPedidos = await prisma.statusPedido.findMany()
    * ```
    */
  get statusPedido(): Prisma.StatusPedidoDelegate<ExtArgs>;

  /**
   * `prisma.statusPagamento`: Exposes CRUD operations for the **StatusPagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusPagamentos
    * const statusPagamentos = await prisma.statusPagamento.findMany()
    * ```
    */
  get statusPagamento(): Prisma.StatusPagamentoDelegate<ExtArgs>;

  /**
   * `prisma.cardapio`: Exposes CRUD operations for the **Cardapio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cardapios
    * const cardapios = await prisma.cardapio.findMany()
    * ```
    */
  get cardapio(): Prisma.CardapioDelegate<ExtArgs>;

  /**
   * `prisma.produtosDoPedido`: Exposes CRUD operations for the **ProdutosDoPedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProdutosDoPedidos
    * const produtosDoPedidos = await prisma.produtosDoPedido.findMany()
    * ```
    */
  get produtosDoPedido(): Prisma.ProdutosDoPedidoDelegate<ExtArgs>;

  /**
   * `prisma.produto`: Exposes CRUD operations for the **Produto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produtos
    * const produtos = await prisma.produto.findMany()
    * ```
    */
  get produto(): Prisma.ProdutoDelegate<ExtArgs>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs>;

  /**
   * `prisma.categoriaProduto`: Exposes CRUD operations for the **CategoriaProduto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriaProdutos
    * const categoriaProdutos = await prisma.categoriaProduto.findMany()
    * ```
    */
  get categoriaProduto(): Prisma.CategoriaProdutoDelegate<ExtArgs>;

  /**
   * `prisma.produtosDoCardapio`: Exposes CRUD operations for the **ProdutosDoCardapio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProdutosDoCardapios
    * const produtosDoCardapios = await prisma.produtosDoCardapio.findMany()
    * ```
    */
  get produtosDoCardapio(): Prisma.ProdutosDoCardapioDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Cliente: 'Cliente',
    TipoAcesso: 'TipoAcesso',
    Usuario: 'Usuario',
    Funcionario: 'Funcionario',
    Pedido: 'Pedido',
    StatusPedido: 'StatusPedido',
    StatusPagamento: 'StatusPagamento',
    Cardapio: 'Cardapio',
    ProdutosDoPedido: 'ProdutosDoPedido',
    Produto: 'Produto',
    Pagamento: 'Pagamento',
    CategoriaProduto: 'CategoriaProduto',
    ProdutosDoCardapio: 'ProdutosDoCardapio'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'cliente' | 'tipoAcesso' | 'usuario' | 'funcionario' | 'pedido' | 'statusPedido' | 'statusPagamento' | 'cardapio' | 'produtosDoPedido' | 'produto' | 'pagamento' | 'categoriaProduto' | 'produtosDoCardapio'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>,
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      TipoAcesso: {
        payload: Prisma.$TipoAcessoPayload<ExtArgs>
        fields: Prisma.TipoAcessoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoAcessoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoAcessoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>
          }
          findFirst: {
            args: Prisma.TipoAcessoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoAcessoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>
          }
          findMany: {
            args: Prisma.TipoAcessoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>[]
          }
          create: {
            args: Prisma.TipoAcessoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>
          }
          createMany: {
            args: Prisma.TipoAcessoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TipoAcessoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>
          }
          update: {
            args: Prisma.TipoAcessoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>
          }
          deleteMany: {
            args: Prisma.TipoAcessoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TipoAcessoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TipoAcessoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoAcessoPayload>
          }
          aggregate: {
            args: Prisma.TipoAcessoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipoAcesso>
          }
          groupBy: {
            args: Prisma.TipoAcessoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TipoAcessoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoAcessoCountArgs<ExtArgs>,
            result: $Utils.Optional<TipoAcessoCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Funcionario: {
        payload: Prisma.$FuncionarioPayload<ExtArgs>
        fields: Prisma.FuncionarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FuncionarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FuncionarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>
          }
          findFirst: {
            args: Prisma.FuncionarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FuncionarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>
          }
          findMany: {
            args: Prisma.FuncionarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>[]
          }
          create: {
            args: Prisma.FuncionarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>
          }
          createMany: {
            args: Prisma.FuncionarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FuncionarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>
          }
          update: {
            args: Prisma.FuncionarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>
          }
          deleteMany: {
            args: Prisma.FuncionarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FuncionarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FuncionarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FuncionarioPayload>
          }
          aggregate: {
            args: Prisma.FuncionarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFuncionario>
          }
          groupBy: {
            args: Prisma.FuncionarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FuncionarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.FuncionarioCountArgs<ExtArgs>,
            result: $Utils.Optional<FuncionarioCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>,
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      StatusPedido: {
        payload: Prisma.$StatusPedidoPayload<ExtArgs>
        fields: Prisma.StatusPedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusPedidoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusPedidoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>
          }
          findFirst: {
            args: Prisma.StatusPedidoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusPedidoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>
          }
          findMany: {
            args: Prisma.StatusPedidoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>[]
          }
          create: {
            args: Prisma.StatusPedidoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>
          }
          createMany: {
            args: Prisma.StatusPedidoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StatusPedidoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>
          }
          update: {
            args: Prisma.StatusPedidoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>
          }
          deleteMany: {
            args: Prisma.StatusPedidoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StatusPedidoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StatusPedidoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPedidoPayload>
          }
          aggregate: {
            args: Prisma.StatusPedidoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStatusPedido>
          }
          groupBy: {
            args: Prisma.StatusPedidoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StatusPedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusPedidoCountArgs<ExtArgs>,
            result: $Utils.Optional<StatusPedidoCountAggregateOutputType> | number
          }
        }
      }
      StatusPagamento: {
        payload: Prisma.$StatusPagamentoPayload<ExtArgs>
        fields: Prisma.StatusPagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusPagamentoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusPagamentoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>
          }
          findFirst: {
            args: Prisma.StatusPagamentoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusPagamentoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>
          }
          findMany: {
            args: Prisma.StatusPagamentoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>[]
          }
          create: {
            args: Prisma.StatusPagamentoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>
          }
          createMany: {
            args: Prisma.StatusPagamentoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StatusPagamentoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>
          }
          update: {
            args: Prisma.StatusPagamentoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>
          }
          deleteMany: {
            args: Prisma.StatusPagamentoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StatusPagamentoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StatusPagamentoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPagamentoPayload>
          }
          aggregate: {
            args: Prisma.StatusPagamentoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStatusPagamento>
          }
          groupBy: {
            args: Prisma.StatusPagamentoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StatusPagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusPagamentoCountArgs<ExtArgs>,
            result: $Utils.Optional<StatusPagamentoCountAggregateOutputType> | number
          }
        }
      }
      Cardapio: {
        payload: Prisma.$CardapioPayload<ExtArgs>
        fields: Prisma.CardapioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardapioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardapioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>
          }
          findFirst: {
            args: Prisma.CardapioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardapioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>
          }
          findMany: {
            args: Prisma.CardapioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>[]
          }
          create: {
            args: Prisma.CardapioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>
          }
          createMany: {
            args: Prisma.CardapioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CardapioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>
          }
          update: {
            args: Prisma.CardapioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>
          }
          deleteMany: {
            args: Prisma.CardapioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CardapioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CardapioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CardapioPayload>
          }
          aggregate: {
            args: Prisma.CardapioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCardapio>
          }
          groupBy: {
            args: Prisma.CardapioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CardapioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardapioCountArgs<ExtArgs>,
            result: $Utils.Optional<CardapioCountAggregateOutputType> | number
          }
        }
      }
      ProdutosDoPedido: {
        payload: Prisma.$ProdutosDoPedidoPayload<ExtArgs>
        fields: Prisma.ProdutosDoPedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdutosDoPedidoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdutosDoPedidoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>
          }
          findFirst: {
            args: Prisma.ProdutosDoPedidoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdutosDoPedidoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>
          }
          findMany: {
            args: Prisma.ProdutosDoPedidoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>[]
          }
          create: {
            args: Prisma.ProdutosDoPedidoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>
          }
          createMany: {
            args: Prisma.ProdutosDoPedidoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProdutosDoPedidoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>
          }
          update: {
            args: Prisma.ProdutosDoPedidoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>
          }
          deleteMany: {
            args: Prisma.ProdutosDoPedidoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProdutosDoPedidoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProdutosDoPedidoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoPedidoPayload>
          }
          aggregate: {
            args: Prisma.ProdutosDoPedidoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProdutosDoPedido>
          }
          groupBy: {
            args: Prisma.ProdutosDoPedidoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProdutosDoPedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdutosDoPedidoCountArgs<ExtArgs>,
            result: $Utils.Optional<ProdutosDoPedidoCountAggregateOutputType> | number
          }
        }
      }
      Produto: {
        payload: Prisma.$ProdutoPayload<ExtArgs>
        fields: Prisma.ProdutoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdutoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdutoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findFirst: {
            args: Prisma.ProdutoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdutoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findMany: {
            args: Prisma.ProdutoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          create: {
            args: Prisma.ProdutoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          createMany: {
            args: Prisma.ProdutoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProdutoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          update: {
            args: Prisma.ProdutoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          deleteMany: {
            args: Prisma.ProdutoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProdutoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProdutoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          aggregate: {
            args: Prisma.ProdutoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduto>
          }
          groupBy: {
            args: Prisma.ProdutoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProdutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdutoCountArgs<ExtArgs>,
            result: $Utils.Optional<ProdutoCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>,
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
      CategoriaProduto: {
        payload: Prisma.$CategoriaProdutoPayload<ExtArgs>
        fields: Prisma.CategoriaProdutoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaProdutoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaProdutoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>
          }
          findFirst: {
            args: Prisma.CategoriaProdutoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaProdutoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>
          }
          findMany: {
            args: Prisma.CategoriaProdutoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>[]
          }
          create: {
            args: Prisma.CategoriaProdutoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>
          }
          createMany: {
            args: Prisma.CategoriaProdutoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoriaProdutoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>
          }
          update: {
            args: Prisma.CategoriaProdutoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaProdutoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaProdutoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaProdutoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaProdutoPayload>
          }
          aggregate: {
            args: Prisma.CategoriaProdutoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoriaProduto>
          }
          groupBy: {
            args: Prisma.CategoriaProdutoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaProdutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaProdutoCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaProdutoCountAggregateOutputType> | number
          }
        }
      }
      ProdutosDoCardapio: {
        payload: Prisma.$ProdutosDoCardapioPayload<ExtArgs>
        fields: Prisma.ProdutosDoCardapioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdutosDoCardapioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdutosDoCardapioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>
          }
          findFirst: {
            args: Prisma.ProdutosDoCardapioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdutosDoCardapioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>
          }
          findMany: {
            args: Prisma.ProdutosDoCardapioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>[]
          }
          create: {
            args: Prisma.ProdutosDoCardapioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>
          }
          createMany: {
            args: Prisma.ProdutosDoCardapioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProdutosDoCardapioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>
          }
          update: {
            args: Prisma.ProdutosDoCardapioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>
          }
          deleteMany: {
            args: Prisma.ProdutosDoCardapioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProdutosDoCardapioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProdutosDoCardapioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProdutosDoCardapioPayload>
          }
          aggregate: {
            args: Prisma.ProdutosDoCardapioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProdutosDoCardapio>
          }
          groupBy: {
            args: Prisma.ProdutosDoCardapioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProdutosDoCardapioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdutosDoCardapioCountArgs<ExtArgs>,
            result: $Utils.Optional<ProdutosDoCardapioCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    pedido: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | ClienteCountOutputTypeCountPedidoArgs
  }

  // Custom InputTypes

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }



  /**
   * Count Type PedidoCountOutputType
   */

  export type PedidoCountOutputType = {
    pagamento: number
    ProdutosDoPedido: number
  }

  export type PedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamento?: boolean | PedidoCountOutputTypeCountPagamentoArgs
    ProdutosDoPedido?: boolean | PedidoCountOutputTypeCountProdutosDoPedidoArgs
  }

  // Custom InputTypes

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }


  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountProdutosDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutosDoPedidoWhereInput
  }



  /**
   * Count Type StatusPedidoCountOutputType
   */

  export type StatusPedidoCountOutputType = {
    pedido: number
  }

  export type StatusPedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | StatusPedidoCountOutputTypeCountPedidoArgs
  }

  // Custom InputTypes

  /**
   * StatusPedidoCountOutputType without action
   */
  export type StatusPedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedidoCountOutputType
     */
    select?: StatusPedidoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StatusPedidoCountOutputType without action
   */
  export type StatusPedidoCountOutputTypeCountPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }



  /**
   * Count Type StatusPagamentoCountOutputType
   */

  export type StatusPagamentoCountOutputType = {
    pagamento: number
  }

  export type StatusPagamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamento?: boolean | StatusPagamentoCountOutputTypeCountPagamentoArgs
  }

  // Custom InputTypes

  /**
   * StatusPagamentoCountOutputType without action
   */
  export type StatusPagamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamentoCountOutputType
     */
    select?: StatusPagamentoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StatusPagamentoCountOutputType without action
   */
  export type StatusPagamentoCountOutputTypeCountPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }



  /**
   * Count Type CardapioCountOutputType
   */

  export type CardapioCountOutputType = {
    produtosDoCardapio: number
  }

  export type CardapioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtosDoCardapio?: boolean | CardapioCountOutputTypeCountProdutosDoCardapioArgs
  }

  // Custom InputTypes

  /**
   * CardapioCountOutputType without action
   */
  export type CardapioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardapioCountOutputType
     */
    select?: CardapioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CardapioCountOutputType without action
   */
  export type CardapioCountOutputTypeCountProdutosDoCardapioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutosDoCardapioWhereInput
  }



  /**
   * Count Type ProdutoCountOutputType
   */

  export type ProdutoCountOutputType = {
    produtosDoCardapio: number
    ProdutosDoPedido: number
  }

  export type ProdutoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtosDoCardapio?: boolean | ProdutoCountOutputTypeCountProdutosDoCardapioArgs
    ProdutosDoPedido?: boolean | ProdutoCountOutputTypeCountProdutosDoPedidoArgs
  }

  // Custom InputTypes

  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutoCountOutputType
     */
    select?: ProdutoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeCountProdutosDoCardapioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutosDoCardapioWhereInput
  }


  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeCountProdutosDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutosDoPedidoWhereInput
  }



  /**
   * Count Type CategoriaProdutoCountOutputType
   */

  export type CategoriaProdutoCountOutputType = {
    produto: number
  }

  export type CategoriaProdutoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produto?: boolean | CategoriaProdutoCountOutputTypeCountProdutoArgs
  }

  // Custom InputTypes

  /**
   * CategoriaProdutoCountOutputType without action
   */
  export type CategoriaProdutoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProdutoCountOutputType
     */
    select?: CategoriaProdutoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoriaProdutoCountOutputType without action
   */
  export type CategoriaProdutoCountOutputTypeCountProdutoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nome: string | null
    email: string | null
    cpf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nome: string | null
    email: string | null
    cpf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    usuarioId: number
    nome: number
    email: number
    cpf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nome?: true
    email?: true
    cpf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    usuarioId: number
    nome: string | null
    email: string
    cpf: string
    createdAt: Date
    updatedAt: Date
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    pedido?: boolean | Cliente$pedidoArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    pedido?: boolean | Cliente$pedidoArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      pedido: Prisma.$PedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      nome: string | null
      email: string
      cpf: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }


  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClienteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClienteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClienteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
    **/
    create<T extends ClienteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clientes.
     *     @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const cliente = await prisma.cliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClienteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
    **/
    delete<T extends ClienteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClienteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClienteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClienteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
    **/
    upsert<T extends ClienteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>
    ): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    pedido<T extends Cliente$pedidoArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$pedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
    readonly usuarioId: FieldRef<"Cliente", 'Int'>
    readonly nome: FieldRef<"Cliente", 'String'>
    readonly email: FieldRef<"Cliente", 'String'>
    readonly cpf: FieldRef<"Cliente", 'String'>
    readonly createdAt: FieldRef<"Cliente", 'DateTime'>
    readonly updatedAt: FieldRef<"Cliente", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }


  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }


  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }


  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }


  /**
   * Cliente.pedido
   */
  export type Cliente$pedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
  }



  /**
   * Model TipoAcesso
   */

  export type AggregateTipoAcesso = {
    _count: TipoAcessoCountAggregateOutputType | null
    _avg: TipoAcessoAvgAggregateOutputType | null
    _sum: TipoAcessoSumAggregateOutputType | null
    _min: TipoAcessoMinAggregateOutputType | null
    _max: TipoAcessoMaxAggregateOutputType | null
  }

  export type TipoAcessoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoAcessoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoAcessoMinAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TipoAcessoMaxAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TipoAcessoCountAggregateOutputType = {
    id: number
    enumerador: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TipoAcessoAvgAggregateInputType = {
    id?: true
  }

  export type TipoAcessoSumAggregateInputType = {
    id?: true
  }

  export type TipoAcessoMinAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TipoAcessoMaxAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TipoAcessoCountAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TipoAcessoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAcesso to aggregate.
     */
    where?: TipoAcessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAcessos to fetch.
     */
    orderBy?: TipoAcessoOrderByWithRelationInput | TipoAcessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoAcessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAcessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoAcessos
    **/
    _count?: true | TipoAcessoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoAcessoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoAcessoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoAcessoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoAcessoMaxAggregateInputType
  }

  export type GetTipoAcessoAggregateType<T extends TipoAcessoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoAcesso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoAcesso[P]>
      : GetScalarType<T[P], AggregateTipoAcesso[P]>
  }




  export type TipoAcessoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoAcessoWhereInput
    orderBy?: TipoAcessoOrderByWithAggregationInput | TipoAcessoOrderByWithAggregationInput[]
    by: TipoAcessoScalarFieldEnum[] | TipoAcessoScalarFieldEnum
    having?: TipoAcessoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoAcessoCountAggregateInputType | true
    _avg?: TipoAcessoAvgAggregateInputType
    _sum?: TipoAcessoSumAggregateInputType
    _min?: TipoAcessoMinAggregateInputType
    _max?: TipoAcessoMaxAggregateInputType
  }

  export type TipoAcessoGroupByOutputType = {
    id: number
    enumerador: string
    createdAt: Date
    updatedAt: Date
    _count: TipoAcessoCountAggregateOutputType | null
    _avg: TipoAcessoAvgAggregateOutputType | null
    _sum: TipoAcessoSumAggregateOutputType | null
    _min: TipoAcessoMinAggregateOutputType | null
    _max: TipoAcessoMaxAggregateOutputType | null
  }

  type GetTipoAcessoGroupByPayload<T extends TipoAcessoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoAcessoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoAcessoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoAcessoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoAcessoGroupByOutputType[P]>
        }
      >
    >


  export type TipoAcessoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tipoAcesso"]>

  export type TipoAcessoSelectScalar = {
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TipoAcessoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoAcesso"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enumerador: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tipoAcesso"]>
    composites: {}
  }


  type TipoAcessoGetPayload<S extends boolean | null | undefined | TipoAcessoDefaultArgs> = $Result.GetResult<Prisma.$TipoAcessoPayload, S>

  type TipoAcessoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TipoAcessoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TipoAcessoCountAggregateInputType | true
    }

  export interface TipoAcessoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoAcesso'], meta: { name: 'TipoAcesso' } }
    /**
     * Find zero or one TipoAcesso that matches the filter.
     * @param {TipoAcessoFindUniqueArgs} args - Arguments to find a TipoAcesso
     * @example
     * // Get one TipoAcesso
     * const tipoAcesso = await prisma.tipoAcesso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoAcessoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TipoAcessoFindUniqueArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TipoAcesso that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TipoAcessoFindUniqueOrThrowArgs} args - Arguments to find a TipoAcesso
     * @example
     * // Get one TipoAcesso
     * const tipoAcesso = await prisma.tipoAcesso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoAcessoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoAcessoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TipoAcesso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoFindFirstArgs} args - Arguments to find a TipoAcesso
     * @example
     * // Get one TipoAcesso
     * const tipoAcesso = await prisma.tipoAcesso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoAcessoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoAcessoFindFirstArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TipoAcesso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoFindFirstOrThrowArgs} args - Arguments to find a TipoAcesso
     * @example
     * // Get one TipoAcesso
     * const tipoAcesso = await prisma.tipoAcesso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoAcessoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoAcessoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TipoAcessos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoAcessos
     * const tipoAcessos = await prisma.tipoAcesso.findMany()
     * 
     * // Get first 10 TipoAcessos
     * const tipoAcessos = await prisma.tipoAcesso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoAcessoWithIdOnly = await prisma.tipoAcesso.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoAcessoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoAcessoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TipoAcesso.
     * @param {TipoAcessoCreateArgs} args - Arguments to create a TipoAcesso.
     * @example
     * // Create one TipoAcesso
     * const TipoAcesso = await prisma.tipoAcesso.create({
     *   data: {
     *     // ... data to create a TipoAcesso
     *   }
     * })
     * 
    **/
    create<T extends TipoAcessoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TipoAcessoCreateArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TipoAcessos.
     *     @param {TipoAcessoCreateManyArgs} args - Arguments to create many TipoAcessos.
     *     @example
     *     // Create many TipoAcessos
     *     const tipoAcesso = await prisma.tipoAcesso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoAcessoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoAcessoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TipoAcesso.
     * @param {TipoAcessoDeleteArgs} args - Arguments to delete one TipoAcesso.
     * @example
     * // Delete one TipoAcesso
     * const TipoAcesso = await prisma.tipoAcesso.delete({
     *   where: {
     *     // ... filter to delete one TipoAcesso
     *   }
     * })
     * 
    **/
    delete<T extends TipoAcessoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TipoAcessoDeleteArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TipoAcesso.
     * @param {TipoAcessoUpdateArgs} args - Arguments to update one TipoAcesso.
     * @example
     * // Update one TipoAcesso
     * const tipoAcesso = await prisma.tipoAcesso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoAcessoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TipoAcessoUpdateArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TipoAcessos.
     * @param {TipoAcessoDeleteManyArgs} args - Arguments to filter TipoAcessos to delete.
     * @example
     * // Delete a few TipoAcessos
     * const { count } = await prisma.tipoAcesso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoAcessoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoAcessoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAcessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoAcessos
     * const tipoAcesso = await prisma.tipoAcesso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoAcessoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TipoAcessoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoAcesso.
     * @param {TipoAcessoUpsertArgs} args - Arguments to update or create a TipoAcesso.
     * @example
     * // Update or create a TipoAcesso
     * const tipoAcesso = await prisma.tipoAcesso.upsert({
     *   create: {
     *     // ... data to create a TipoAcesso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoAcesso we want to update
     *   }
     * })
    **/
    upsert<T extends TipoAcessoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TipoAcessoUpsertArgs<ExtArgs>>
    ): Prisma__TipoAcessoClient<$Result.GetResult<Prisma.$TipoAcessoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TipoAcessos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoCountArgs} args - Arguments to filter TipoAcessos to count.
     * @example
     * // Count the number of TipoAcessos
     * const count = await prisma.tipoAcesso.count({
     *   where: {
     *     // ... the filter for the TipoAcessos we want to count
     *   }
     * })
    **/
    count<T extends TipoAcessoCountArgs>(
      args?: Subset<T, TipoAcessoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoAcessoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoAcesso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoAcessoAggregateArgs>(args: Subset<T, TipoAcessoAggregateArgs>): Prisma.PrismaPromise<GetTipoAcessoAggregateType<T>>

    /**
     * Group by TipoAcesso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAcessoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoAcessoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoAcessoGroupByArgs['orderBy'] }
        : { orderBy?: TipoAcessoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoAcessoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoAcessoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoAcesso model
   */
  readonly fields: TipoAcessoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoAcesso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoAcessoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TipoAcesso model
   */ 
  interface TipoAcessoFieldRefs {
    readonly id: FieldRef<"TipoAcesso", 'Int'>
    readonly enumerador: FieldRef<"TipoAcesso", 'String'>
    readonly createdAt: FieldRef<"TipoAcesso", 'DateTime'>
    readonly updatedAt: FieldRef<"TipoAcesso", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TipoAcesso findUnique
   */
  export type TipoAcessoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * Filter, which TipoAcesso to fetch.
     */
    where: TipoAcessoWhereUniqueInput
  }


  /**
   * TipoAcesso findUniqueOrThrow
   */
  export type TipoAcessoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * Filter, which TipoAcesso to fetch.
     */
    where: TipoAcessoWhereUniqueInput
  }


  /**
   * TipoAcesso findFirst
   */
  export type TipoAcessoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * Filter, which TipoAcesso to fetch.
     */
    where?: TipoAcessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAcessos to fetch.
     */
    orderBy?: TipoAcessoOrderByWithRelationInput | TipoAcessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAcessos.
     */
    cursor?: TipoAcessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAcessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAcessos.
     */
    distinct?: TipoAcessoScalarFieldEnum | TipoAcessoScalarFieldEnum[]
  }


  /**
   * TipoAcesso findFirstOrThrow
   */
  export type TipoAcessoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * Filter, which TipoAcesso to fetch.
     */
    where?: TipoAcessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAcessos to fetch.
     */
    orderBy?: TipoAcessoOrderByWithRelationInput | TipoAcessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAcessos.
     */
    cursor?: TipoAcessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAcessos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAcessos.
     */
    distinct?: TipoAcessoScalarFieldEnum | TipoAcessoScalarFieldEnum[]
  }


  /**
   * TipoAcesso findMany
   */
  export type TipoAcessoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * Filter, which TipoAcessos to fetch.
     */
    where?: TipoAcessoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAcessos to fetch.
     */
    orderBy?: TipoAcessoOrderByWithRelationInput | TipoAcessoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoAcessos.
     */
    cursor?: TipoAcessoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAcessos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAcessos.
     */
    skip?: number
    distinct?: TipoAcessoScalarFieldEnum | TipoAcessoScalarFieldEnum[]
  }


  /**
   * TipoAcesso create
   */
  export type TipoAcessoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * The data needed to create a TipoAcesso.
     */
    data: XOR<TipoAcessoCreateInput, TipoAcessoUncheckedCreateInput>
  }


  /**
   * TipoAcesso createMany
   */
  export type TipoAcessoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoAcessos.
     */
    data: TipoAcessoCreateManyInput | TipoAcessoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TipoAcesso update
   */
  export type TipoAcessoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * The data needed to update a TipoAcesso.
     */
    data: XOR<TipoAcessoUpdateInput, TipoAcessoUncheckedUpdateInput>
    /**
     * Choose, which TipoAcesso to update.
     */
    where: TipoAcessoWhereUniqueInput
  }


  /**
   * TipoAcesso updateMany
   */
  export type TipoAcessoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoAcessos.
     */
    data: XOR<TipoAcessoUpdateManyMutationInput, TipoAcessoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAcessos to update
     */
    where?: TipoAcessoWhereInput
  }


  /**
   * TipoAcesso upsert
   */
  export type TipoAcessoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * The filter to search for the TipoAcesso to update in case it exists.
     */
    where: TipoAcessoWhereUniqueInput
    /**
     * In case the TipoAcesso found by the `where` argument doesn't exist, create a new TipoAcesso with this data.
     */
    create: XOR<TipoAcessoCreateInput, TipoAcessoUncheckedCreateInput>
    /**
     * In case the TipoAcesso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoAcessoUpdateInput, TipoAcessoUncheckedUpdateInput>
  }


  /**
   * TipoAcesso delete
   */
  export type TipoAcessoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
    /**
     * Filter which TipoAcesso to delete.
     */
    where: TipoAcessoWhereUniqueInput
  }


  /**
   * TipoAcesso deleteMany
   */
  export type TipoAcessoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAcessos to delete
     */
    where?: TipoAcessoWhereInput
  }


  /**
   * TipoAcesso without action
   */
  export type TipoAcessoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAcesso
     */
    select?: TipoAcessoSelect<ExtArgs> | null
  }



  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    tipoAcesso: string | null
    login: string | null
    senha: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    tipoAcesso: string | null
    login: string | null
    senha: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    tipoAcesso: number
    login: number
    senha: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    tipoAcesso?: true
    login?: true
    senha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    tipoAcesso?: true
    login?: true
    senha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    tipoAcesso?: true
    login?: true
    senha?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    tipoAcesso: string
    login: string
    senha: string
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoAcesso?: boolean
    login?: boolean
    senha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funcionario?: boolean | Usuario$funcionarioArgs<ExtArgs>
    cliente?: boolean | Usuario$clienteArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    tipoAcesso?: boolean
    login?: boolean
    senha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funcionario?: boolean | Usuario$funcionarioArgs<ExtArgs>
    cliente?: boolean | Usuario$clienteArgs<ExtArgs>
  }


  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      funcionario: Prisma.$FuncionarioPayload<ExtArgs> | null
      cliente: Prisma.$ClientePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoAcesso: string
      login: string
      senha: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }


  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    funcionario<T extends Usuario$funcionarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$funcionarioArgs<ExtArgs>>): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    cliente<T extends Usuario$clienteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$clienteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly tipoAcesso: FieldRef<"Usuario", 'String'>
    readonly login: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario.funcionario
   */
  export type Usuario$funcionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    where?: FuncionarioWhereInput
  }


  /**
   * Usuario.cliente
   */
  export type Usuario$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
  }


  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
  }



  /**
   * Model Funcionario
   */

  export type AggregateFuncionario = {
    _count: FuncionarioCountAggregateOutputType | null
    _avg: FuncionarioAvgAggregateOutputType | null
    _sum: FuncionarioSumAggregateOutputType | null
    _min: FuncionarioMinAggregateOutputType | null
    _max: FuncionarioMaxAggregateOutputType | null
  }

  export type FuncionarioAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type FuncionarioSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type FuncionarioMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nome: string | null
    cargo: string | null
    admin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FuncionarioMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nome: string | null
    cargo: string | null
    admin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FuncionarioCountAggregateOutputType = {
    id: number
    usuarioId: number
    nome: number
    cargo: number
    admin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FuncionarioAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type FuncionarioSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type FuncionarioMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nome?: true
    cargo?: true
    admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FuncionarioMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nome?: true
    cargo?: true
    admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FuncionarioCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nome?: true
    cargo?: true
    admin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FuncionarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funcionario to aggregate.
     */
    where?: FuncionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funcionarios to fetch.
     */
    orderBy?: FuncionarioOrderByWithRelationInput | FuncionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FuncionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funcionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funcionarios
    **/
    _count?: true | FuncionarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FuncionarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FuncionarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FuncionarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FuncionarioMaxAggregateInputType
  }

  export type GetFuncionarioAggregateType<T extends FuncionarioAggregateArgs> = {
        [P in keyof T & keyof AggregateFuncionario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFuncionario[P]>
      : GetScalarType<T[P], AggregateFuncionario[P]>
  }




  export type FuncionarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FuncionarioWhereInput
    orderBy?: FuncionarioOrderByWithAggregationInput | FuncionarioOrderByWithAggregationInput[]
    by: FuncionarioScalarFieldEnum[] | FuncionarioScalarFieldEnum
    having?: FuncionarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FuncionarioCountAggregateInputType | true
    _avg?: FuncionarioAvgAggregateInputType
    _sum?: FuncionarioSumAggregateInputType
    _min?: FuncionarioMinAggregateInputType
    _max?: FuncionarioMaxAggregateInputType
  }

  export type FuncionarioGroupByOutputType = {
    id: number
    usuarioId: number
    nome: string
    cargo: string
    admin: string
    createdAt: Date
    updatedAt: Date
    _count: FuncionarioCountAggregateOutputType | null
    _avg: FuncionarioAvgAggregateOutputType | null
    _sum: FuncionarioSumAggregateOutputType | null
    _min: FuncionarioMinAggregateOutputType | null
    _max: FuncionarioMaxAggregateOutputType | null
  }

  type GetFuncionarioGroupByPayload<T extends FuncionarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FuncionarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FuncionarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FuncionarioGroupByOutputType[P]>
            : GetScalarType<T[P], FuncionarioGroupByOutputType[P]>
        }
      >
    >


  export type FuncionarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nome?: boolean
    cargo?: boolean
    admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funcionario"]>

  export type FuncionarioSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nome?: boolean
    cargo?: boolean
    admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FuncionarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $FuncionarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Funcionario"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      nome: string
      cargo: string
      admin: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["funcionario"]>
    composites: {}
  }


  type FuncionarioGetPayload<S extends boolean | null | undefined | FuncionarioDefaultArgs> = $Result.GetResult<Prisma.$FuncionarioPayload, S>

  type FuncionarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FuncionarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FuncionarioCountAggregateInputType | true
    }

  export interface FuncionarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Funcionario'], meta: { name: 'Funcionario' } }
    /**
     * Find zero or one Funcionario that matches the filter.
     * @param {FuncionarioFindUniqueArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FuncionarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FuncionarioFindUniqueArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Funcionario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FuncionarioFindUniqueOrThrowArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FuncionarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FuncionarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Funcionario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioFindFirstArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FuncionarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FuncionarioFindFirstArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Funcionario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioFindFirstOrThrowArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FuncionarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FuncionarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Funcionarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funcionarios
     * const funcionarios = await prisma.funcionario.findMany()
     * 
     * // Get first 10 Funcionarios
     * const funcionarios = await prisma.funcionario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funcionarioWithIdOnly = await prisma.funcionario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FuncionarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FuncionarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Funcionario.
     * @param {FuncionarioCreateArgs} args - Arguments to create a Funcionario.
     * @example
     * // Create one Funcionario
     * const Funcionario = await prisma.funcionario.create({
     *   data: {
     *     // ... data to create a Funcionario
     *   }
     * })
     * 
    **/
    create<T extends FuncionarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FuncionarioCreateArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Funcionarios.
     *     @param {FuncionarioCreateManyArgs} args - Arguments to create many Funcionarios.
     *     @example
     *     // Create many Funcionarios
     *     const funcionario = await prisma.funcionario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FuncionarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FuncionarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Funcionario.
     * @param {FuncionarioDeleteArgs} args - Arguments to delete one Funcionario.
     * @example
     * // Delete one Funcionario
     * const Funcionario = await prisma.funcionario.delete({
     *   where: {
     *     // ... filter to delete one Funcionario
     *   }
     * })
     * 
    **/
    delete<T extends FuncionarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FuncionarioDeleteArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Funcionario.
     * @param {FuncionarioUpdateArgs} args - Arguments to update one Funcionario.
     * @example
     * // Update one Funcionario
     * const funcionario = await prisma.funcionario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FuncionarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FuncionarioUpdateArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Funcionarios.
     * @param {FuncionarioDeleteManyArgs} args - Arguments to filter Funcionarios to delete.
     * @example
     * // Delete a few Funcionarios
     * const { count } = await prisma.funcionario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FuncionarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FuncionarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funcionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funcionarios
     * const funcionario = await prisma.funcionario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FuncionarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FuncionarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Funcionario.
     * @param {FuncionarioUpsertArgs} args - Arguments to update or create a Funcionario.
     * @example
     * // Update or create a Funcionario
     * const funcionario = await prisma.funcionario.upsert({
     *   create: {
     *     // ... data to create a Funcionario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funcionario we want to update
     *   }
     * })
    **/
    upsert<T extends FuncionarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FuncionarioUpsertArgs<ExtArgs>>
    ): Prisma__FuncionarioClient<$Result.GetResult<Prisma.$FuncionarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Funcionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioCountArgs} args - Arguments to filter Funcionarios to count.
     * @example
     * // Count the number of Funcionarios
     * const count = await prisma.funcionario.count({
     *   where: {
     *     // ... the filter for the Funcionarios we want to count
     *   }
     * })
    **/
    count<T extends FuncionarioCountArgs>(
      args?: Subset<T, FuncionarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FuncionarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funcionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FuncionarioAggregateArgs>(args: Subset<T, FuncionarioAggregateArgs>): Prisma.PrismaPromise<GetFuncionarioAggregateType<T>>

    /**
     * Group by Funcionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FuncionarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FuncionarioGroupByArgs['orderBy'] }
        : { orderBy?: FuncionarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FuncionarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFuncionarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Funcionario model
   */
  readonly fields: FuncionarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Funcionario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FuncionarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Funcionario model
   */ 
  interface FuncionarioFieldRefs {
    readonly id: FieldRef<"Funcionario", 'Int'>
    readonly usuarioId: FieldRef<"Funcionario", 'Int'>
    readonly nome: FieldRef<"Funcionario", 'String'>
    readonly cargo: FieldRef<"Funcionario", 'String'>
    readonly admin: FieldRef<"Funcionario", 'String'>
    readonly createdAt: FieldRef<"Funcionario", 'DateTime'>
    readonly updatedAt: FieldRef<"Funcionario", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Funcionario findUnique
   */
  export type FuncionarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * Filter, which Funcionario to fetch.
     */
    where: FuncionarioWhereUniqueInput
  }


  /**
   * Funcionario findUniqueOrThrow
   */
  export type FuncionarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * Filter, which Funcionario to fetch.
     */
    where: FuncionarioWhereUniqueInput
  }


  /**
   * Funcionario findFirst
   */
  export type FuncionarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * Filter, which Funcionario to fetch.
     */
    where?: FuncionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funcionarios to fetch.
     */
    orderBy?: FuncionarioOrderByWithRelationInput | FuncionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funcionarios.
     */
    cursor?: FuncionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funcionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funcionarios.
     */
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }


  /**
   * Funcionario findFirstOrThrow
   */
  export type FuncionarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * Filter, which Funcionario to fetch.
     */
    where?: FuncionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funcionarios to fetch.
     */
    orderBy?: FuncionarioOrderByWithRelationInput | FuncionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funcionarios.
     */
    cursor?: FuncionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funcionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funcionarios.
     */
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }


  /**
   * Funcionario findMany
   */
  export type FuncionarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * Filter, which Funcionarios to fetch.
     */
    where?: FuncionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funcionarios to fetch.
     */
    orderBy?: FuncionarioOrderByWithRelationInput | FuncionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funcionarios.
     */
    cursor?: FuncionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funcionarios.
     */
    skip?: number
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }


  /**
   * Funcionario create
   */
  export type FuncionarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Funcionario.
     */
    data: XOR<FuncionarioCreateInput, FuncionarioUncheckedCreateInput>
  }


  /**
   * Funcionario createMany
   */
  export type FuncionarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funcionarios.
     */
    data: FuncionarioCreateManyInput | FuncionarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Funcionario update
   */
  export type FuncionarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Funcionario.
     */
    data: XOR<FuncionarioUpdateInput, FuncionarioUncheckedUpdateInput>
    /**
     * Choose, which Funcionario to update.
     */
    where: FuncionarioWhereUniqueInput
  }


  /**
   * Funcionario updateMany
   */
  export type FuncionarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funcionarios.
     */
    data: XOR<FuncionarioUpdateManyMutationInput, FuncionarioUncheckedUpdateManyInput>
    /**
     * Filter which Funcionarios to update
     */
    where?: FuncionarioWhereInput
  }


  /**
   * Funcionario upsert
   */
  export type FuncionarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Funcionario to update in case it exists.
     */
    where: FuncionarioWhereUniqueInput
    /**
     * In case the Funcionario found by the `where` argument doesn't exist, create a new Funcionario with this data.
     */
    create: XOR<FuncionarioCreateInput, FuncionarioUncheckedCreateInput>
    /**
     * In case the Funcionario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FuncionarioUpdateInput, FuncionarioUncheckedUpdateInput>
  }


  /**
   * Funcionario delete
   */
  export type FuncionarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
    /**
     * Filter which Funcionario to delete.
     */
    where: FuncionarioWhereUniqueInput
  }


  /**
   * Funcionario deleteMany
   */
  export type FuncionarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funcionarios to delete
     */
    where?: FuncionarioWhereInput
  }


  /**
   * Funcionario without action
   */
  export type FuncionarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funcionario
     */
    select?: FuncionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FuncionarioInclude<ExtArgs> | null
  }



  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    clienteId: number | null
    statusPedidoId: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    clienteId: number | null
    statusPedidoId: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    clienteId: number | null
    statusPedidoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    clienteId: number | null
    statusPedidoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    clienteId: number
    statusPedidoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    clienteId?: true
    statusPedidoId?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    clienteId?: true
    statusPedidoId?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    clienteId?: true
    statusPedidoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    clienteId?: true
    statusPedidoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    clienteId?: true
    statusPedidoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    id: number
    clienteId: number
    statusPedidoId: number
    createdAt: Date
    updatedAt: Date
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    statusPedidoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    pagamento?: boolean | Pedido$pagamentoArgs<ExtArgs>
    statusPedido?: boolean | StatusPedidoDefaultArgs<ExtArgs>
    ProdutosDoPedido?: boolean | Pedido$ProdutosDoPedidoArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectScalar = {
    id?: boolean
    clienteId?: boolean
    statusPedidoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    pagamento?: boolean | Pedido$pagamentoArgs<ExtArgs>
    statusPedido?: boolean | StatusPedidoDefaultArgs<ExtArgs>
    ProdutosDoPedido?: boolean | Pedido$ProdutosDoPedidoArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      pagamento: Prisma.$PagamentoPayload<ExtArgs>[]
      statusPedido: Prisma.$StatusPedidoPayload<ExtArgs>
      ProdutosDoPedido: Prisma.$ProdutosDoPedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clienteId: number
      statusPedidoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }


  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pedido that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    pagamento<T extends Pedido$pagamentoArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$pagamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findMany'> | Null>;

    statusPedido<T extends StatusPedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatusPedidoDefaultArgs<ExtArgs>>): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ProdutosDoPedido<T extends Pedido$ProdutosDoPedidoArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$ProdutosDoPedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Pedido model
   */ 
  interface PedidoFieldRefs {
    readonly id: FieldRef<"Pedido", 'Int'>
    readonly clienteId: FieldRef<"Pedido", 'Int'>
    readonly statusPedidoId: FieldRef<"Pedido", 'Int'>
    readonly createdAt: FieldRef<"Pedido", 'DateTime'>
    readonly updatedAt: FieldRef<"Pedido", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido.pagamento
   */
  export type Pedido$pagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }


  /**
   * Pedido.ProdutosDoPedido
   */
  export type Pedido$ProdutosDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    where?: ProdutosDoPedidoWhereInput
    orderBy?: ProdutosDoPedidoOrderByWithRelationInput | ProdutosDoPedidoOrderByWithRelationInput[]
    cursor?: ProdutosDoPedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutosDoPedidoScalarFieldEnum | ProdutosDoPedidoScalarFieldEnum[]
  }


  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
  }



  /**
   * Model StatusPedido
   */

  export type AggregateStatusPedido = {
    _count: StatusPedidoCountAggregateOutputType | null
    _avg: StatusPedidoAvgAggregateOutputType | null
    _sum: StatusPedidoSumAggregateOutputType | null
    _min: StatusPedidoMinAggregateOutputType | null
    _max: StatusPedidoMaxAggregateOutputType | null
  }

  export type StatusPedidoAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusPedidoSumAggregateOutputType = {
    id: number | null
  }

  export type StatusPedidoMinAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusPedidoMaxAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusPedidoCountAggregateOutputType = {
    id: number
    enumerador: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatusPedidoAvgAggregateInputType = {
    id?: true
  }

  export type StatusPedidoSumAggregateInputType = {
    id?: true
  }

  export type StatusPedidoMinAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusPedidoMaxAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusPedidoCountAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatusPedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPedido to aggregate.
     */
    where?: StatusPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPedidos to fetch.
     */
    orderBy?: StatusPedidoOrderByWithRelationInput | StatusPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusPedidos
    **/
    _count?: true | StatusPedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusPedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusPedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusPedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusPedidoMaxAggregateInputType
  }

  export type GetStatusPedidoAggregateType<T extends StatusPedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusPedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusPedido[P]>
      : GetScalarType<T[P], AggregateStatusPedido[P]>
  }




  export type StatusPedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusPedidoWhereInput
    orderBy?: StatusPedidoOrderByWithAggregationInput | StatusPedidoOrderByWithAggregationInput[]
    by: StatusPedidoScalarFieldEnum[] | StatusPedidoScalarFieldEnum
    having?: StatusPedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusPedidoCountAggregateInputType | true
    _avg?: StatusPedidoAvgAggregateInputType
    _sum?: StatusPedidoSumAggregateInputType
    _min?: StatusPedidoMinAggregateInputType
    _max?: StatusPedidoMaxAggregateInputType
  }

  export type StatusPedidoGroupByOutputType = {
    id: number
    enumerador: string
    createdAt: Date
    updatedAt: Date
    _count: StatusPedidoCountAggregateOutputType | null
    _avg: StatusPedidoAvgAggregateOutputType | null
    _sum: StatusPedidoSumAggregateOutputType | null
    _min: StatusPedidoMinAggregateOutputType | null
    _max: StatusPedidoMaxAggregateOutputType | null
  }

  type GetStatusPedidoGroupByPayload<T extends StatusPedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusPedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusPedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusPedidoGroupByOutputType[P]>
            : GetScalarType<T[P], StatusPedidoGroupByOutputType[P]>
        }
      >
    >


  export type StatusPedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | StatusPedido$pedidoArgs<ExtArgs>
    _count?: boolean | StatusPedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusPedido"]>

  export type StatusPedidoSelectScalar = {
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatusPedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | StatusPedido$pedidoArgs<ExtArgs>
    _count?: boolean | StatusPedidoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StatusPedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusPedido"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enumerador: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statusPedido"]>
    composites: {}
  }


  type StatusPedidoGetPayload<S extends boolean | null | undefined | StatusPedidoDefaultArgs> = $Result.GetResult<Prisma.$StatusPedidoPayload, S>

  type StatusPedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatusPedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatusPedidoCountAggregateInputType | true
    }

  export interface StatusPedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusPedido'], meta: { name: 'StatusPedido' } }
    /**
     * Find zero or one StatusPedido that matches the filter.
     * @param {StatusPedidoFindUniqueArgs} args - Arguments to find a StatusPedido
     * @example
     * // Get one StatusPedido
     * const statusPedido = await prisma.statusPedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusPedidoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPedidoFindUniqueArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StatusPedido that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StatusPedidoFindUniqueOrThrowArgs} args - Arguments to find a StatusPedido
     * @example
     * // Get one StatusPedido
     * const statusPedido = await prisma.statusPedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatusPedidoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPedidoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StatusPedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoFindFirstArgs} args - Arguments to find a StatusPedido
     * @example
     * // Get one StatusPedido
     * const statusPedido = await prisma.statusPedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusPedidoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPedidoFindFirstArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StatusPedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoFindFirstOrThrowArgs} args - Arguments to find a StatusPedido
     * @example
     * // Get one StatusPedido
     * const statusPedido = await prisma.statusPedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatusPedidoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPedidoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StatusPedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusPedidos
     * const statusPedidos = await prisma.statusPedido.findMany()
     * 
     * // Get first 10 StatusPedidos
     * const statusPedidos = await prisma.statusPedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusPedidoWithIdOnly = await prisma.statusPedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatusPedidoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPedidoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StatusPedido.
     * @param {StatusPedidoCreateArgs} args - Arguments to create a StatusPedido.
     * @example
     * // Create one StatusPedido
     * const StatusPedido = await prisma.statusPedido.create({
     *   data: {
     *     // ... data to create a StatusPedido
     *   }
     * })
     * 
    **/
    create<T extends StatusPedidoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPedidoCreateArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StatusPedidos.
     *     @param {StatusPedidoCreateManyArgs} args - Arguments to create many StatusPedidos.
     *     @example
     *     // Create many StatusPedidos
     *     const statusPedido = await prisma.statusPedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusPedidoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPedidoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StatusPedido.
     * @param {StatusPedidoDeleteArgs} args - Arguments to delete one StatusPedido.
     * @example
     * // Delete one StatusPedido
     * const StatusPedido = await prisma.statusPedido.delete({
     *   where: {
     *     // ... filter to delete one StatusPedido
     *   }
     * })
     * 
    **/
    delete<T extends StatusPedidoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPedidoDeleteArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StatusPedido.
     * @param {StatusPedidoUpdateArgs} args - Arguments to update one StatusPedido.
     * @example
     * // Update one StatusPedido
     * const statusPedido = await prisma.statusPedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusPedidoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPedidoUpdateArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StatusPedidos.
     * @param {StatusPedidoDeleteManyArgs} args - Arguments to filter StatusPedidos to delete.
     * @example
     * // Delete a few StatusPedidos
     * const { count } = await prisma.statusPedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusPedidoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPedidoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusPedidos
     * const statusPedido = await prisma.statusPedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusPedidoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPedidoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusPedido.
     * @param {StatusPedidoUpsertArgs} args - Arguments to update or create a StatusPedido.
     * @example
     * // Update or create a StatusPedido
     * const statusPedido = await prisma.statusPedido.upsert({
     *   create: {
     *     // ... data to create a StatusPedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusPedido we want to update
     *   }
     * })
    **/
    upsert<T extends StatusPedidoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPedidoUpsertArgs<ExtArgs>>
    ): Prisma__StatusPedidoClient<$Result.GetResult<Prisma.$StatusPedidoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StatusPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoCountArgs} args - Arguments to filter StatusPedidos to count.
     * @example
     * // Count the number of StatusPedidos
     * const count = await prisma.statusPedido.count({
     *   where: {
     *     // ... the filter for the StatusPedidos we want to count
     *   }
     * })
    **/
    count<T extends StatusPedidoCountArgs>(
      args?: Subset<T, StatusPedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusPedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusPedidoAggregateArgs>(args: Subset<T, StatusPedidoAggregateArgs>): Prisma.PrismaPromise<GetStatusPedidoAggregateType<T>>

    /**
     * Group by StatusPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusPedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusPedidoGroupByArgs['orderBy'] }
        : { orderBy?: StatusPedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusPedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusPedido model
   */
  readonly fields: StatusPedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusPedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusPedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pedido<T extends StatusPedido$pedidoArgs<ExtArgs> = {}>(args?: Subset<T, StatusPedido$pedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StatusPedido model
   */ 
  interface StatusPedidoFieldRefs {
    readonly id: FieldRef<"StatusPedido", 'Int'>
    readonly enumerador: FieldRef<"StatusPedido", 'String'>
    readonly createdAt: FieldRef<"StatusPedido", 'DateTime'>
    readonly updatedAt: FieldRef<"StatusPedido", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StatusPedido findUnique
   */
  export type StatusPedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPedido to fetch.
     */
    where: StatusPedidoWhereUniqueInput
  }


  /**
   * StatusPedido findUniqueOrThrow
   */
  export type StatusPedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPedido to fetch.
     */
    where: StatusPedidoWhereUniqueInput
  }


  /**
   * StatusPedido findFirst
   */
  export type StatusPedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPedido to fetch.
     */
    where?: StatusPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPedidos to fetch.
     */
    orderBy?: StatusPedidoOrderByWithRelationInput | StatusPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPedidos.
     */
    cursor?: StatusPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPedidos.
     */
    distinct?: StatusPedidoScalarFieldEnum | StatusPedidoScalarFieldEnum[]
  }


  /**
   * StatusPedido findFirstOrThrow
   */
  export type StatusPedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPedido to fetch.
     */
    where?: StatusPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPedidos to fetch.
     */
    orderBy?: StatusPedidoOrderByWithRelationInput | StatusPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPedidos.
     */
    cursor?: StatusPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPedidos.
     */
    distinct?: StatusPedidoScalarFieldEnum | StatusPedidoScalarFieldEnum[]
  }


  /**
   * StatusPedido findMany
   */
  export type StatusPedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPedidos to fetch.
     */
    where?: StatusPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPedidos to fetch.
     */
    orderBy?: StatusPedidoOrderByWithRelationInput | StatusPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusPedidos.
     */
    cursor?: StatusPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPedidos.
     */
    skip?: number
    distinct?: StatusPedidoScalarFieldEnum | StatusPedidoScalarFieldEnum[]
  }


  /**
   * StatusPedido create
   */
  export type StatusPedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusPedido.
     */
    data: XOR<StatusPedidoCreateInput, StatusPedidoUncheckedCreateInput>
  }


  /**
   * StatusPedido createMany
   */
  export type StatusPedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusPedidos.
     */
    data: StatusPedidoCreateManyInput | StatusPedidoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StatusPedido update
   */
  export type StatusPedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusPedido.
     */
    data: XOR<StatusPedidoUpdateInput, StatusPedidoUncheckedUpdateInput>
    /**
     * Choose, which StatusPedido to update.
     */
    where: StatusPedidoWhereUniqueInput
  }


  /**
   * StatusPedido updateMany
   */
  export type StatusPedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusPedidos.
     */
    data: XOR<StatusPedidoUpdateManyMutationInput, StatusPedidoUncheckedUpdateManyInput>
    /**
     * Filter which StatusPedidos to update
     */
    where?: StatusPedidoWhereInput
  }


  /**
   * StatusPedido upsert
   */
  export type StatusPedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusPedido to update in case it exists.
     */
    where: StatusPedidoWhereUniqueInput
    /**
     * In case the StatusPedido found by the `where` argument doesn't exist, create a new StatusPedido with this data.
     */
    create: XOR<StatusPedidoCreateInput, StatusPedidoUncheckedCreateInput>
    /**
     * In case the StatusPedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusPedidoUpdateInput, StatusPedidoUncheckedUpdateInput>
  }


  /**
   * StatusPedido delete
   */
  export type StatusPedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
    /**
     * Filter which StatusPedido to delete.
     */
    where: StatusPedidoWhereUniqueInput
  }


  /**
   * StatusPedido deleteMany
   */
  export type StatusPedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPedidos to delete
     */
    where?: StatusPedidoWhereInput
  }


  /**
   * StatusPedido.pedido
   */
  export type StatusPedido$pedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * StatusPedido without action
   */
  export type StatusPedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPedido
     */
    select?: StatusPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPedidoInclude<ExtArgs> | null
  }



  /**
   * Model StatusPagamento
   */

  export type AggregateStatusPagamento = {
    _count: StatusPagamentoCountAggregateOutputType | null
    _avg: StatusPagamentoAvgAggregateOutputType | null
    _sum: StatusPagamentoSumAggregateOutputType | null
    _min: StatusPagamentoMinAggregateOutputType | null
    _max: StatusPagamentoMaxAggregateOutputType | null
  }

  export type StatusPagamentoAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusPagamentoSumAggregateOutputType = {
    id: number | null
  }

  export type StatusPagamentoMinAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusPagamentoMaxAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusPagamentoCountAggregateOutputType = {
    id: number
    enumerador: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatusPagamentoAvgAggregateInputType = {
    id?: true
  }

  export type StatusPagamentoSumAggregateInputType = {
    id?: true
  }

  export type StatusPagamentoMinAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusPagamentoMaxAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusPagamentoCountAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatusPagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPagamento to aggregate.
     */
    where?: StatusPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPagamentos to fetch.
     */
    orderBy?: StatusPagamentoOrderByWithRelationInput | StatusPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusPagamentos
    **/
    _count?: true | StatusPagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusPagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusPagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusPagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusPagamentoMaxAggregateInputType
  }

  export type GetStatusPagamentoAggregateType<T extends StatusPagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusPagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusPagamento[P]>
      : GetScalarType<T[P], AggregateStatusPagamento[P]>
  }




  export type StatusPagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusPagamentoWhereInput
    orderBy?: StatusPagamentoOrderByWithAggregationInput | StatusPagamentoOrderByWithAggregationInput[]
    by: StatusPagamentoScalarFieldEnum[] | StatusPagamentoScalarFieldEnum
    having?: StatusPagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusPagamentoCountAggregateInputType | true
    _avg?: StatusPagamentoAvgAggregateInputType
    _sum?: StatusPagamentoSumAggregateInputType
    _min?: StatusPagamentoMinAggregateInputType
    _max?: StatusPagamentoMaxAggregateInputType
  }

  export type StatusPagamentoGroupByOutputType = {
    id: number
    enumerador: string
    createdAt: Date
    updatedAt: Date
    _count: StatusPagamentoCountAggregateOutputType | null
    _avg: StatusPagamentoAvgAggregateOutputType | null
    _sum: StatusPagamentoSumAggregateOutputType | null
    _min: StatusPagamentoMinAggregateOutputType | null
    _max: StatusPagamentoMaxAggregateOutputType | null
  }

  type GetStatusPagamentoGroupByPayload<T extends StatusPagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusPagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusPagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusPagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], StatusPagamentoGroupByOutputType[P]>
        }
      >
    >


  export type StatusPagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pagamento?: boolean | StatusPagamento$pagamentoArgs<ExtArgs>
    _count?: boolean | StatusPagamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusPagamento"]>

  export type StatusPagamentoSelectScalar = {
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatusPagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamento?: boolean | StatusPagamento$pagamentoArgs<ExtArgs>
    _count?: boolean | StatusPagamentoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StatusPagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusPagamento"
    objects: {
      pagamento: Prisma.$PagamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enumerador: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statusPagamento"]>
    composites: {}
  }


  type StatusPagamentoGetPayload<S extends boolean | null | undefined | StatusPagamentoDefaultArgs> = $Result.GetResult<Prisma.$StatusPagamentoPayload, S>

  type StatusPagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatusPagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatusPagamentoCountAggregateInputType | true
    }

  export interface StatusPagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusPagamento'], meta: { name: 'StatusPagamento' } }
    /**
     * Find zero or one StatusPagamento that matches the filter.
     * @param {StatusPagamentoFindUniqueArgs} args - Arguments to find a StatusPagamento
     * @example
     * // Get one StatusPagamento
     * const statusPagamento = await prisma.statusPagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusPagamentoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPagamentoFindUniqueArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StatusPagamento that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StatusPagamentoFindUniqueOrThrowArgs} args - Arguments to find a StatusPagamento
     * @example
     * // Get one StatusPagamento
     * const statusPagamento = await prisma.statusPagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatusPagamentoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPagamentoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StatusPagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoFindFirstArgs} args - Arguments to find a StatusPagamento
     * @example
     * // Get one StatusPagamento
     * const statusPagamento = await prisma.statusPagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusPagamentoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPagamentoFindFirstArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StatusPagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoFindFirstOrThrowArgs} args - Arguments to find a StatusPagamento
     * @example
     * // Get one StatusPagamento
     * const statusPagamento = await prisma.statusPagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatusPagamentoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPagamentoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StatusPagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusPagamentos
     * const statusPagamentos = await prisma.statusPagamento.findMany()
     * 
     * // Get first 10 StatusPagamentos
     * const statusPagamentos = await prisma.statusPagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusPagamentoWithIdOnly = await prisma.statusPagamento.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatusPagamentoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPagamentoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StatusPagamento.
     * @param {StatusPagamentoCreateArgs} args - Arguments to create a StatusPagamento.
     * @example
     * // Create one StatusPagamento
     * const StatusPagamento = await prisma.statusPagamento.create({
     *   data: {
     *     // ... data to create a StatusPagamento
     *   }
     * })
     * 
    **/
    create<T extends StatusPagamentoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPagamentoCreateArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StatusPagamentos.
     *     @param {StatusPagamentoCreateManyArgs} args - Arguments to create many StatusPagamentos.
     *     @example
     *     // Create many StatusPagamentos
     *     const statusPagamento = await prisma.statusPagamento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusPagamentoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPagamentoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StatusPagamento.
     * @param {StatusPagamentoDeleteArgs} args - Arguments to delete one StatusPagamento.
     * @example
     * // Delete one StatusPagamento
     * const StatusPagamento = await prisma.statusPagamento.delete({
     *   where: {
     *     // ... filter to delete one StatusPagamento
     *   }
     * })
     * 
    **/
    delete<T extends StatusPagamentoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPagamentoDeleteArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StatusPagamento.
     * @param {StatusPagamentoUpdateArgs} args - Arguments to update one StatusPagamento.
     * @example
     * // Update one StatusPagamento
     * const statusPagamento = await prisma.statusPagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusPagamentoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPagamentoUpdateArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StatusPagamentos.
     * @param {StatusPagamentoDeleteManyArgs} args - Arguments to filter StatusPagamentos to delete.
     * @example
     * // Delete a few StatusPagamentos
     * const { count } = await prisma.statusPagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusPagamentoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPagamentoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusPagamentos
     * const statusPagamento = await prisma.statusPagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusPagamentoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPagamentoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusPagamento.
     * @param {StatusPagamentoUpsertArgs} args - Arguments to update or create a StatusPagamento.
     * @example
     * // Update or create a StatusPagamento
     * const statusPagamento = await prisma.statusPagamento.upsert({
     *   create: {
     *     // ... data to create a StatusPagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusPagamento we want to update
     *   }
     * })
    **/
    upsert<T extends StatusPagamentoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPagamentoUpsertArgs<ExtArgs>>
    ): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StatusPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoCountArgs} args - Arguments to filter StatusPagamentos to count.
     * @example
     * // Count the number of StatusPagamentos
     * const count = await prisma.statusPagamento.count({
     *   where: {
     *     // ... the filter for the StatusPagamentos we want to count
     *   }
     * })
    **/
    count<T extends StatusPagamentoCountArgs>(
      args?: Subset<T, StatusPagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusPagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusPagamentoAggregateArgs>(args: Subset<T, StatusPagamentoAggregateArgs>): Prisma.PrismaPromise<GetStatusPagamentoAggregateType<T>>

    /**
     * Group by StatusPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusPagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusPagamentoGroupByArgs['orderBy'] }
        : { orderBy?: StatusPagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusPagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusPagamento model
   */
  readonly fields: StatusPagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusPagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusPagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pagamento<T extends StatusPagamento$pagamentoArgs<ExtArgs> = {}>(args?: Subset<T, StatusPagamento$pagamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StatusPagamento model
   */ 
  interface StatusPagamentoFieldRefs {
    readonly id: FieldRef<"StatusPagamento", 'Int'>
    readonly enumerador: FieldRef<"StatusPagamento", 'String'>
    readonly createdAt: FieldRef<"StatusPagamento", 'DateTime'>
    readonly updatedAt: FieldRef<"StatusPagamento", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StatusPagamento findUnique
   */
  export type StatusPagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPagamento to fetch.
     */
    where: StatusPagamentoWhereUniqueInput
  }


  /**
   * StatusPagamento findUniqueOrThrow
   */
  export type StatusPagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPagamento to fetch.
     */
    where: StatusPagamentoWhereUniqueInput
  }


  /**
   * StatusPagamento findFirst
   */
  export type StatusPagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPagamento to fetch.
     */
    where?: StatusPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPagamentos to fetch.
     */
    orderBy?: StatusPagamentoOrderByWithRelationInput | StatusPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPagamentos.
     */
    cursor?: StatusPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPagamentos.
     */
    distinct?: StatusPagamentoScalarFieldEnum | StatusPagamentoScalarFieldEnum[]
  }


  /**
   * StatusPagamento findFirstOrThrow
   */
  export type StatusPagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPagamento to fetch.
     */
    where?: StatusPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPagamentos to fetch.
     */
    orderBy?: StatusPagamentoOrderByWithRelationInput | StatusPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPagamentos.
     */
    cursor?: StatusPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPagamentos.
     */
    distinct?: StatusPagamentoScalarFieldEnum | StatusPagamentoScalarFieldEnum[]
  }


  /**
   * StatusPagamento findMany
   */
  export type StatusPagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which StatusPagamentos to fetch.
     */
    where?: StatusPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPagamentos to fetch.
     */
    orderBy?: StatusPagamentoOrderByWithRelationInput | StatusPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusPagamentos.
     */
    cursor?: StatusPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPagamentos.
     */
    skip?: number
    distinct?: StatusPagamentoScalarFieldEnum | StatusPagamentoScalarFieldEnum[]
  }


  /**
   * StatusPagamento create
   */
  export type StatusPagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusPagamento.
     */
    data: XOR<StatusPagamentoCreateInput, StatusPagamentoUncheckedCreateInput>
  }


  /**
   * StatusPagamento createMany
   */
  export type StatusPagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusPagamentos.
     */
    data: StatusPagamentoCreateManyInput | StatusPagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StatusPagamento update
   */
  export type StatusPagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusPagamento.
     */
    data: XOR<StatusPagamentoUpdateInput, StatusPagamentoUncheckedUpdateInput>
    /**
     * Choose, which StatusPagamento to update.
     */
    where: StatusPagamentoWhereUniqueInput
  }


  /**
   * StatusPagamento updateMany
   */
  export type StatusPagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusPagamentos.
     */
    data: XOR<StatusPagamentoUpdateManyMutationInput, StatusPagamentoUncheckedUpdateManyInput>
    /**
     * Filter which StatusPagamentos to update
     */
    where?: StatusPagamentoWhereInput
  }


  /**
   * StatusPagamento upsert
   */
  export type StatusPagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusPagamento to update in case it exists.
     */
    where: StatusPagamentoWhereUniqueInput
    /**
     * In case the StatusPagamento found by the `where` argument doesn't exist, create a new StatusPagamento with this data.
     */
    create: XOR<StatusPagamentoCreateInput, StatusPagamentoUncheckedCreateInput>
    /**
     * In case the StatusPagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusPagamentoUpdateInput, StatusPagamentoUncheckedUpdateInput>
  }


  /**
   * StatusPagamento delete
   */
  export type StatusPagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
    /**
     * Filter which StatusPagamento to delete.
     */
    where: StatusPagamentoWhereUniqueInput
  }


  /**
   * StatusPagamento deleteMany
   */
  export type StatusPagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPagamentos to delete
     */
    where?: StatusPagamentoWhereInput
  }


  /**
   * StatusPagamento.pagamento
   */
  export type StatusPagamento$pagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }


  /**
   * StatusPagamento without action
   */
  export type StatusPagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPagamento
     */
    select?: StatusPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusPagamentoInclude<ExtArgs> | null
  }



  /**
   * Model Cardapio
   */

  export type AggregateCardapio = {
    _count: CardapioCountAggregateOutputType | null
    _avg: CardapioAvgAggregateOutputType | null
    _sum: CardapioSumAggregateOutputType | null
    _min: CardapioMinAggregateOutputType | null
    _max: CardapioMaxAggregateOutputType | null
  }

  export type CardapioAvgAggregateOutputType = {
    id: number | null
  }

  export type CardapioSumAggregateOutputType = {
    id: number | null
  }

  export type CardapioMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardapioMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardapioCountAggregateOutputType = {
    id: number
    descricao: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardapioAvgAggregateInputType = {
    id?: true
  }

  export type CardapioSumAggregateInputType = {
    id?: true
  }

  export type CardapioMinAggregateInputType = {
    id?: true
    descricao?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardapioMaxAggregateInputType = {
    id?: true
    descricao?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardapioCountAggregateInputType = {
    id?: true
    descricao?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardapioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cardapio to aggregate.
     */
    where?: CardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cardapios to fetch.
     */
    orderBy?: CardapioOrderByWithRelationInput | CardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cardapios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cardapios
    **/
    _count?: true | CardapioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardapioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardapioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardapioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardapioMaxAggregateInputType
  }

  export type GetCardapioAggregateType<T extends CardapioAggregateArgs> = {
        [P in keyof T & keyof AggregateCardapio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardapio[P]>
      : GetScalarType<T[P], AggregateCardapio[P]>
  }




  export type CardapioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardapioWhereInput
    orderBy?: CardapioOrderByWithAggregationInput | CardapioOrderByWithAggregationInput[]
    by: CardapioScalarFieldEnum[] | CardapioScalarFieldEnum
    having?: CardapioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardapioCountAggregateInputType | true
    _avg?: CardapioAvgAggregateInputType
    _sum?: CardapioSumAggregateInputType
    _min?: CardapioMinAggregateInputType
    _max?: CardapioMaxAggregateInputType
  }

  export type CardapioGroupByOutputType = {
    id: number
    descricao: string
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: CardapioCountAggregateOutputType | null
    _avg: CardapioAvgAggregateOutputType | null
    _sum: CardapioSumAggregateOutputType | null
    _min: CardapioMinAggregateOutputType | null
    _max: CardapioMaxAggregateOutputType | null
  }

  type GetCardapioGroupByPayload<T extends CardapioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardapioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardapioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardapioGroupByOutputType[P]>
            : GetScalarType<T[P], CardapioGroupByOutputType[P]>
        }
      >
    >


  export type CardapioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produtosDoCardapio?: boolean | Cardapio$produtosDoCardapioArgs<ExtArgs>
    _count?: boolean | CardapioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardapio"]>

  export type CardapioSelectScalar = {
    id?: boolean
    descricao?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardapioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtosDoCardapio?: boolean | Cardapio$produtosDoCardapioArgs<ExtArgs>
    _count?: boolean | CardapioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CardapioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cardapio"
    objects: {
      produtosDoCardapio: Prisma.$ProdutosDoCardapioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cardapio"]>
    composites: {}
  }


  type CardapioGetPayload<S extends boolean | null | undefined | CardapioDefaultArgs> = $Result.GetResult<Prisma.$CardapioPayload, S>

  type CardapioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CardapioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CardapioCountAggregateInputType | true
    }

  export interface CardapioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cardapio'], meta: { name: 'Cardapio' } }
    /**
     * Find zero or one Cardapio that matches the filter.
     * @param {CardapioFindUniqueArgs} args - Arguments to find a Cardapio
     * @example
     * // Get one Cardapio
     * const cardapio = await prisma.cardapio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CardapioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CardapioFindUniqueArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cardapio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CardapioFindUniqueOrThrowArgs} args - Arguments to find a Cardapio
     * @example
     * // Get one Cardapio
     * const cardapio = await prisma.cardapio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CardapioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CardapioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cardapio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioFindFirstArgs} args - Arguments to find a Cardapio
     * @example
     * // Get one Cardapio
     * const cardapio = await prisma.cardapio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CardapioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CardapioFindFirstArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cardapio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioFindFirstOrThrowArgs} args - Arguments to find a Cardapio
     * @example
     * // Get one Cardapio
     * const cardapio = await prisma.cardapio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CardapioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CardapioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cardapios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cardapios
     * const cardapios = await prisma.cardapio.findMany()
     * 
     * // Get first 10 Cardapios
     * const cardapios = await prisma.cardapio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardapioWithIdOnly = await prisma.cardapio.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CardapioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CardapioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cardapio.
     * @param {CardapioCreateArgs} args - Arguments to create a Cardapio.
     * @example
     * // Create one Cardapio
     * const Cardapio = await prisma.cardapio.create({
     *   data: {
     *     // ... data to create a Cardapio
     *   }
     * })
     * 
    **/
    create<T extends CardapioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CardapioCreateArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cardapios.
     *     @param {CardapioCreateManyArgs} args - Arguments to create many Cardapios.
     *     @example
     *     // Create many Cardapios
     *     const cardapio = await prisma.cardapio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CardapioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CardapioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cardapio.
     * @param {CardapioDeleteArgs} args - Arguments to delete one Cardapio.
     * @example
     * // Delete one Cardapio
     * const Cardapio = await prisma.cardapio.delete({
     *   where: {
     *     // ... filter to delete one Cardapio
     *   }
     * })
     * 
    **/
    delete<T extends CardapioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CardapioDeleteArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cardapio.
     * @param {CardapioUpdateArgs} args - Arguments to update one Cardapio.
     * @example
     * // Update one Cardapio
     * const cardapio = await prisma.cardapio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CardapioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CardapioUpdateArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cardapios.
     * @param {CardapioDeleteManyArgs} args - Arguments to filter Cardapios to delete.
     * @example
     * // Delete a few Cardapios
     * const { count } = await prisma.cardapio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CardapioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CardapioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cardapios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cardapios
     * const cardapio = await prisma.cardapio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CardapioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CardapioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cardapio.
     * @param {CardapioUpsertArgs} args - Arguments to update or create a Cardapio.
     * @example
     * // Update or create a Cardapio
     * const cardapio = await prisma.cardapio.upsert({
     *   create: {
     *     // ... data to create a Cardapio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cardapio we want to update
     *   }
     * })
    **/
    upsert<T extends CardapioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CardapioUpsertArgs<ExtArgs>>
    ): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cardapios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioCountArgs} args - Arguments to filter Cardapios to count.
     * @example
     * // Count the number of Cardapios
     * const count = await prisma.cardapio.count({
     *   where: {
     *     // ... the filter for the Cardapios we want to count
     *   }
     * })
    **/
    count<T extends CardapioCountArgs>(
      args?: Subset<T, CardapioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardapioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cardapio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardapioAggregateArgs>(args: Subset<T, CardapioAggregateArgs>): Prisma.PrismaPromise<GetCardapioAggregateType<T>>

    /**
     * Group by Cardapio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardapioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardapioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardapioGroupByArgs['orderBy'] }
        : { orderBy?: CardapioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardapioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardapioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cardapio model
   */
  readonly fields: CardapioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cardapio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardapioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produtosDoCardapio<T extends Cardapio$produtosDoCardapioArgs<ExtArgs> = {}>(args?: Subset<T, Cardapio$produtosDoCardapioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Cardapio model
   */ 
  interface CardapioFieldRefs {
    readonly id: FieldRef<"Cardapio", 'Int'>
    readonly descricao: FieldRef<"Cardapio", 'String'>
    readonly ativo: FieldRef<"Cardapio", 'Boolean'>
    readonly createdAt: FieldRef<"Cardapio", 'DateTime'>
    readonly updatedAt: FieldRef<"Cardapio", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Cardapio findUnique
   */
  export type CardapioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * Filter, which Cardapio to fetch.
     */
    where: CardapioWhereUniqueInput
  }


  /**
   * Cardapio findUniqueOrThrow
   */
  export type CardapioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * Filter, which Cardapio to fetch.
     */
    where: CardapioWhereUniqueInput
  }


  /**
   * Cardapio findFirst
   */
  export type CardapioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * Filter, which Cardapio to fetch.
     */
    where?: CardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cardapios to fetch.
     */
    orderBy?: CardapioOrderByWithRelationInput | CardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cardapios.
     */
    cursor?: CardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cardapios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cardapios.
     */
    distinct?: CardapioScalarFieldEnum | CardapioScalarFieldEnum[]
  }


  /**
   * Cardapio findFirstOrThrow
   */
  export type CardapioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * Filter, which Cardapio to fetch.
     */
    where?: CardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cardapios to fetch.
     */
    orderBy?: CardapioOrderByWithRelationInput | CardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cardapios.
     */
    cursor?: CardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cardapios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cardapios.
     */
    distinct?: CardapioScalarFieldEnum | CardapioScalarFieldEnum[]
  }


  /**
   * Cardapio findMany
   */
  export type CardapioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * Filter, which Cardapios to fetch.
     */
    where?: CardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cardapios to fetch.
     */
    orderBy?: CardapioOrderByWithRelationInput | CardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cardapios.
     */
    cursor?: CardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cardapios.
     */
    skip?: number
    distinct?: CardapioScalarFieldEnum | CardapioScalarFieldEnum[]
  }


  /**
   * Cardapio create
   */
  export type CardapioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * The data needed to create a Cardapio.
     */
    data: XOR<CardapioCreateInput, CardapioUncheckedCreateInput>
  }


  /**
   * Cardapio createMany
   */
  export type CardapioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cardapios.
     */
    data: CardapioCreateManyInput | CardapioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Cardapio update
   */
  export type CardapioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * The data needed to update a Cardapio.
     */
    data: XOR<CardapioUpdateInput, CardapioUncheckedUpdateInput>
    /**
     * Choose, which Cardapio to update.
     */
    where: CardapioWhereUniqueInput
  }


  /**
   * Cardapio updateMany
   */
  export type CardapioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cardapios.
     */
    data: XOR<CardapioUpdateManyMutationInput, CardapioUncheckedUpdateManyInput>
    /**
     * Filter which Cardapios to update
     */
    where?: CardapioWhereInput
  }


  /**
   * Cardapio upsert
   */
  export type CardapioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * The filter to search for the Cardapio to update in case it exists.
     */
    where: CardapioWhereUniqueInput
    /**
     * In case the Cardapio found by the `where` argument doesn't exist, create a new Cardapio with this data.
     */
    create: XOR<CardapioCreateInput, CardapioUncheckedCreateInput>
    /**
     * In case the Cardapio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardapioUpdateInput, CardapioUncheckedUpdateInput>
  }


  /**
   * Cardapio delete
   */
  export type CardapioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
    /**
     * Filter which Cardapio to delete.
     */
    where: CardapioWhereUniqueInput
  }


  /**
   * Cardapio deleteMany
   */
  export type CardapioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cardapios to delete
     */
    where?: CardapioWhereInput
  }


  /**
   * Cardapio.produtosDoCardapio
   */
  export type Cardapio$produtosDoCardapioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    where?: ProdutosDoCardapioWhereInput
    orderBy?: ProdutosDoCardapioOrderByWithRelationInput | ProdutosDoCardapioOrderByWithRelationInput[]
    cursor?: ProdutosDoCardapioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutosDoCardapioScalarFieldEnum | ProdutosDoCardapioScalarFieldEnum[]
  }


  /**
   * Cardapio without action
   */
  export type CardapioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cardapio
     */
    select?: CardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CardapioInclude<ExtArgs> | null
  }



  /**
   * Model ProdutosDoPedido
   */

  export type AggregateProdutosDoPedido = {
    _count: ProdutosDoPedidoCountAggregateOutputType | null
    _avg: ProdutosDoPedidoAvgAggregateOutputType | null
    _sum: ProdutosDoPedidoSumAggregateOutputType | null
    _min: ProdutosDoPedidoMinAggregateOutputType | null
    _max: ProdutosDoPedidoMaxAggregateOutputType | null
  }

  export type ProdutosDoPedidoAvgAggregateOutputType = {
    id: number | null
    produtoId: number | null
    pedidoId: number | null
    quantidade: number | null
    valor: Decimal | null
  }

  export type ProdutosDoPedidoSumAggregateOutputType = {
    id: number | null
    produtoId: number | null
    pedidoId: number | null
    quantidade: number | null
    valor: Decimal | null
  }

  export type ProdutosDoPedidoMinAggregateOutputType = {
    id: number | null
    produtoId: number | null
    pedidoId: number | null
    quantidade: number | null
    valor: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProdutosDoPedidoMaxAggregateOutputType = {
    id: number | null
    produtoId: number | null
    pedidoId: number | null
    quantidade: number | null
    valor: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProdutosDoPedidoCountAggregateOutputType = {
    id: number
    produtoId: number
    pedidoId: number
    quantidade: number
    valor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProdutosDoPedidoAvgAggregateInputType = {
    id?: true
    produtoId?: true
    pedidoId?: true
    quantidade?: true
    valor?: true
  }

  export type ProdutosDoPedidoSumAggregateInputType = {
    id?: true
    produtoId?: true
    pedidoId?: true
    quantidade?: true
    valor?: true
  }

  export type ProdutosDoPedidoMinAggregateInputType = {
    id?: true
    produtoId?: true
    pedidoId?: true
    quantidade?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProdutosDoPedidoMaxAggregateInputType = {
    id?: true
    produtoId?: true
    pedidoId?: true
    quantidade?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProdutosDoPedidoCountAggregateInputType = {
    id?: true
    produtoId?: true
    pedidoId?: true
    quantidade?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProdutosDoPedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProdutosDoPedido to aggregate.
     */
    where?: ProdutosDoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoPedidos to fetch.
     */
    orderBy?: ProdutosDoPedidoOrderByWithRelationInput | ProdutosDoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdutosDoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProdutosDoPedidos
    **/
    _count?: true | ProdutosDoPedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutosDoPedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutosDoPedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutosDoPedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutosDoPedidoMaxAggregateInputType
  }

  export type GetProdutosDoPedidoAggregateType<T extends ProdutosDoPedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateProdutosDoPedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProdutosDoPedido[P]>
      : GetScalarType<T[P], AggregateProdutosDoPedido[P]>
  }




  export type ProdutosDoPedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutosDoPedidoWhereInput
    orderBy?: ProdutosDoPedidoOrderByWithAggregationInput | ProdutosDoPedidoOrderByWithAggregationInput[]
    by: ProdutosDoPedidoScalarFieldEnum[] | ProdutosDoPedidoScalarFieldEnum
    having?: ProdutosDoPedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutosDoPedidoCountAggregateInputType | true
    _avg?: ProdutosDoPedidoAvgAggregateInputType
    _sum?: ProdutosDoPedidoSumAggregateInputType
    _min?: ProdutosDoPedidoMinAggregateInputType
    _max?: ProdutosDoPedidoMaxAggregateInputType
  }

  export type ProdutosDoPedidoGroupByOutputType = {
    id: number
    produtoId: number
    pedidoId: number
    quantidade: number
    valor: Decimal
    createdAt: Date
    updatedAt: Date
    _count: ProdutosDoPedidoCountAggregateOutputType | null
    _avg: ProdutosDoPedidoAvgAggregateOutputType | null
    _sum: ProdutosDoPedidoSumAggregateOutputType | null
    _min: ProdutosDoPedidoMinAggregateOutputType | null
    _max: ProdutosDoPedidoMaxAggregateOutputType | null
  }

  type GetProdutosDoPedidoGroupByPayload<T extends ProdutosDoPedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutosDoPedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutosDoPedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutosDoPedidoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutosDoPedidoGroupByOutputType[P]>
        }
      >
    >


  export type ProdutosDoPedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produtoId?: boolean
    pedidoId?: boolean
    quantidade?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produtosDoPedido"]>

  export type ProdutosDoPedidoSelectScalar = {
    id?: boolean
    produtoId?: boolean
    pedidoId?: boolean
    quantidade?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProdutosDoPedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }


  export type $ProdutosDoPedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProdutosDoPedido"
    objects: {
      produto: Prisma.$ProdutoPayload<ExtArgs>
      pedido: Prisma.$PedidoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      produtoId: number
      pedidoId: number
      quantidade: number
      valor: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["produtosDoPedido"]>
    composites: {}
  }


  type ProdutosDoPedidoGetPayload<S extends boolean | null | undefined | ProdutosDoPedidoDefaultArgs> = $Result.GetResult<Prisma.$ProdutosDoPedidoPayload, S>

  type ProdutosDoPedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProdutosDoPedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProdutosDoPedidoCountAggregateInputType | true
    }

  export interface ProdutosDoPedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProdutosDoPedido'], meta: { name: 'ProdutosDoPedido' } }
    /**
     * Find zero or one ProdutosDoPedido that matches the filter.
     * @param {ProdutosDoPedidoFindUniqueArgs} args - Arguments to find a ProdutosDoPedido
     * @example
     * // Get one ProdutosDoPedido
     * const produtosDoPedido = await prisma.produtosDoPedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProdutosDoPedidoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoPedidoFindUniqueArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProdutosDoPedido that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProdutosDoPedidoFindUniqueOrThrowArgs} args - Arguments to find a ProdutosDoPedido
     * @example
     * // Get one ProdutosDoPedido
     * const produtosDoPedido = await prisma.produtosDoPedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProdutosDoPedidoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoPedidoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProdutosDoPedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoFindFirstArgs} args - Arguments to find a ProdutosDoPedido
     * @example
     * // Get one ProdutosDoPedido
     * const produtosDoPedido = await prisma.produtosDoPedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProdutosDoPedidoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoPedidoFindFirstArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProdutosDoPedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoFindFirstOrThrowArgs} args - Arguments to find a ProdutosDoPedido
     * @example
     * // Get one ProdutosDoPedido
     * const produtosDoPedido = await prisma.produtosDoPedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProdutosDoPedidoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoPedidoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProdutosDoPedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProdutosDoPedidos
     * const produtosDoPedidos = await prisma.produtosDoPedido.findMany()
     * 
     * // Get first 10 ProdutosDoPedidos
     * const produtosDoPedidos = await prisma.produtosDoPedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtosDoPedidoWithIdOnly = await prisma.produtosDoPedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProdutosDoPedidoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoPedidoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProdutosDoPedido.
     * @param {ProdutosDoPedidoCreateArgs} args - Arguments to create a ProdutosDoPedido.
     * @example
     * // Create one ProdutosDoPedido
     * const ProdutosDoPedido = await prisma.produtosDoPedido.create({
     *   data: {
     *     // ... data to create a ProdutosDoPedido
     *   }
     * })
     * 
    **/
    create<T extends ProdutosDoPedidoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoPedidoCreateArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProdutosDoPedidos.
     *     @param {ProdutosDoPedidoCreateManyArgs} args - Arguments to create many ProdutosDoPedidos.
     *     @example
     *     // Create many ProdutosDoPedidos
     *     const produtosDoPedido = await prisma.produtosDoPedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProdutosDoPedidoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoPedidoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProdutosDoPedido.
     * @param {ProdutosDoPedidoDeleteArgs} args - Arguments to delete one ProdutosDoPedido.
     * @example
     * // Delete one ProdutosDoPedido
     * const ProdutosDoPedido = await prisma.produtosDoPedido.delete({
     *   where: {
     *     // ... filter to delete one ProdutosDoPedido
     *   }
     * })
     * 
    **/
    delete<T extends ProdutosDoPedidoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoPedidoDeleteArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProdutosDoPedido.
     * @param {ProdutosDoPedidoUpdateArgs} args - Arguments to update one ProdutosDoPedido.
     * @example
     * // Update one ProdutosDoPedido
     * const produtosDoPedido = await prisma.produtosDoPedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProdutosDoPedidoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoPedidoUpdateArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProdutosDoPedidos.
     * @param {ProdutosDoPedidoDeleteManyArgs} args - Arguments to filter ProdutosDoPedidos to delete.
     * @example
     * // Delete a few ProdutosDoPedidos
     * const { count } = await prisma.produtosDoPedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProdutosDoPedidoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoPedidoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProdutosDoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProdutosDoPedidos
     * const produtosDoPedido = await prisma.produtosDoPedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProdutosDoPedidoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoPedidoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProdutosDoPedido.
     * @param {ProdutosDoPedidoUpsertArgs} args - Arguments to update or create a ProdutosDoPedido.
     * @example
     * // Update or create a ProdutosDoPedido
     * const produtosDoPedido = await prisma.produtosDoPedido.upsert({
     *   create: {
     *     // ... data to create a ProdutosDoPedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProdutosDoPedido we want to update
     *   }
     * })
    **/
    upsert<T extends ProdutosDoPedidoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoPedidoUpsertArgs<ExtArgs>>
    ): Prisma__ProdutosDoPedidoClient<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProdutosDoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoCountArgs} args - Arguments to filter ProdutosDoPedidos to count.
     * @example
     * // Count the number of ProdutosDoPedidos
     * const count = await prisma.produtosDoPedido.count({
     *   where: {
     *     // ... the filter for the ProdutosDoPedidos we want to count
     *   }
     * })
    **/
    count<T extends ProdutosDoPedidoCountArgs>(
      args?: Subset<T, ProdutosDoPedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutosDoPedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProdutosDoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutosDoPedidoAggregateArgs>(args: Subset<T, ProdutosDoPedidoAggregateArgs>): Prisma.PrismaPromise<GetProdutosDoPedidoAggregateType<T>>

    /**
     * Group by ProdutosDoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoPedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutosDoPedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutosDoPedidoGroupByArgs['orderBy'] }
        : { orderBy?: ProdutosDoPedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutosDoPedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutosDoPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProdutosDoPedido model
   */
  readonly fields: ProdutosDoPedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProdutosDoPedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdutosDoPedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produto<T extends ProdutoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProdutoDefaultArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProdutosDoPedido model
   */ 
  interface ProdutosDoPedidoFieldRefs {
    readonly id: FieldRef<"ProdutosDoPedido", 'Int'>
    readonly produtoId: FieldRef<"ProdutosDoPedido", 'Int'>
    readonly pedidoId: FieldRef<"ProdutosDoPedido", 'Int'>
    readonly quantidade: FieldRef<"ProdutosDoPedido", 'Int'>
    readonly valor: FieldRef<"ProdutosDoPedido", 'Decimal'>
    readonly createdAt: FieldRef<"ProdutosDoPedido", 'DateTime'>
    readonly updatedAt: FieldRef<"ProdutosDoPedido", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ProdutosDoPedido findUnique
   */
  export type ProdutosDoPedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoPedido to fetch.
     */
    where: ProdutosDoPedidoWhereUniqueInput
  }


  /**
   * ProdutosDoPedido findUniqueOrThrow
   */
  export type ProdutosDoPedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoPedido to fetch.
     */
    where: ProdutosDoPedidoWhereUniqueInput
  }


  /**
   * ProdutosDoPedido findFirst
   */
  export type ProdutosDoPedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoPedido to fetch.
     */
    where?: ProdutosDoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoPedidos to fetch.
     */
    orderBy?: ProdutosDoPedidoOrderByWithRelationInput | ProdutosDoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProdutosDoPedidos.
     */
    cursor?: ProdutosDoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProdutosDoPedidos.
     */
    distinct?: ProdutosDoPedidoScalarFieldEnum | ProdutosDoPedidoScalarFieldEnum[]
  }


  /**
   * ProdutosDoPedido findFirstOrThrow
   */
  export type ProdutosDoPedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoPedido to fetch.
     */
    where?: ProdutosDoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoPedidos to fetch.
     */
    orderBy?: ProdutosDoPedidoOrderByWithRelationInput | ProdutosDoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProdutosDoPedidos.
     */
    cursor?: ProdutosDoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProdutosDoPedidos.
     */
    distinct?: ProdutosDoPedidoScalarFieldEnum | ProdutosDoPedidoScalarFieldEnum[]
  }


  /**
   * ProdutosDoPedido findMany
   */
  export type ProdutosDoPedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoPedidos to fetch.
     */
    where?: ProdutosDoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoPedidos to fetch.
     */
    orderBy?: ProdutosDoPedidoOrderByWithRelationInput | ProdutosDoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProdutosDoPedidos.
     */
    cursor?: ProdutosDoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoPedidos.
     */
    skip?: number
    distinct?: ProdutosDoPedidoScalarFieldEnum | ProdutosDoPedidoScalarFieldEnum[]
  }


  /**
   * ProdutosDoPedido create
   */
  export type ProdutosDoPedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a ProdutosDoPedido.
     */
    data: XOR<ProdutosDoPedidoCreateInput, ProdutosDoPedidoUncheckedCreateInput>
  }


  /**
   * ProdutosDoPedido createMany
   */
  export type ProdutosDoPedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProdutosDoPedidos.
     */
    data: ProdutosDoPedidoCreateManyInput | ProdutosDoPedidoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProdutosDoPedido update
   */
  export type ProdutosDoPedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a ProdutosDoPedido.
     */
    data: XOR<ProdutosDoPedidoUpdateInput, ProdutosDoPedidoUncheckedUpdateInput>
    /**
     * Choose, which ProdutosDoPedido to update.
     */
    where: ProdutosDoPedidoWhereUniqueInput
  }


  /**
   * ProdutosDoPedido updateMany
   */
  export type ProdutosDoPedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProdutosDoPedidos.
     */
    data: XOR<ProdutosDoPedidoUpdateManyMutationInput, ProdutosDoPedidoUncheckedUpdateManyInput>
    /**
     * Filter which ProdutosDoPedidos to update
     */
    where?: ProdutosDoPedidoWhereInput
  }


  /**
   * ProdutosDoPedido upsert
   */
  export type ProdutosDoPedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the ProdutosDoPedido to update in case it exists.
     */
    where: ProdutosDoPedidoWhereUniqueInput
    /**
     * In case the ProdutosDoPedido found by the `where` argument doesn't exist, create a new ProdutosDoPedido with this data.
     */
    create: XOR<ProdutosDoPedidoCreateInput, ProdutosDoPedidoUncheckedCreateInput>
    /**
     * In case the ProdutosDoPedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdutosDoPedidoUpdateInput, ProdutosDoPedidoUncheckedUpdateInput>
  }


  /**
   * ProdutosDoPedido delete
   */
  export type ProdutosDoPedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    /**
     * Filter which ProdutosDoPedido to delete.
     */
    where: ProdutosDoPedidoWhereUniqueInput
  }


  /**
   * ProdutosDoPedido deleteMany
   */
  export type ProdutosDoPedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProdutosDoPedidos to delete
     */
    where?: ProdutosDoPedidoWhereInput
  }


  /**
   * ProdutosDoPedido without action
   */
  export type ProdutosDoPedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
  }



  /**
   * Model Produto
   */

  export type AggregateProduto = {
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  export type ProdutoAvgAggregateOutputType = {
    id: number | null
    categoriaProdutoId: number | null
    preco: Decimal | null
  }

  export type ProdutoSumAggregateOutputType = {
    id: number | null
    categoriaProdutoId: number | null
    preco: Decimal | null
  }

  export type ProdutoMinAggregateOutputType = {
    id: number | null
    categoriaProdutoId: number | null
    descricao: string | null
    preco: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProdutoMaxAggregateOutputType = {
    id: number | null
    categoriaProdutoId: number | null
    descricao: string | null
    preco: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProdutoCountAggregateOutputType = {
    id: number
    categoriaProdutoId: number
    descricao: number
    preco: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProdutoAvgAggregateInputType = {
    id?: true
    categoriaProdutoId?: true
    preco?: true
  }

  export type ProdutoSumAggregateInputType = {
    id?: true
    categoriaProdutoId?: true
    preco?: true
  }

  export type ProdutoMinAggregateInputType = {
    id?: true
    categoriaProdutoId?: true
    descricao?: true
    preco?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProdutoMaxAggregateInputType = {
    id?: true
    categoriaProdutoId?: true
    descricao?: true
    preco?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProdutoCountAggregateInputType = {
    id?: true
    categoriaProdutoId?: true
    descricao?: true
    preco?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProdutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produto to aggregate.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produtos
    **/
    _count?: true | ProdutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutoMaxAggregateInputType
  }

  export type GetProdutoAggregateType<T extends ProdutoAggregateArgs> = {
        [P in keyof T & keyof AggregateProduto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduto[P]>
      : GetScalarType<T[P], AggregateProduto[P]>
  }




  export type ProdutoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithAggregationInput | ProdutoOrderByWithAggregationInput[]
    by: ProdutoScalarFieldEnum[] | ProdutoScalarFieldEnum
    having?: ProdutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutoCountAggregateInputType | true
    _avg?: ProdutoAvgAggregateInputType
    _sum?: ProdutoSumAggregateInputType
    _min?: ProdutoMinAggregateInputType
    _max?: ProdutoMaxAggregateInputType
  }

  export type ProdutoGroupByOutputType = {
    id: number
    categoriaProdutoId: number
    descricao: string
    preco: Decimal
    createdAt: Date
    updatedAt: Date
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  type GetProdutoGroupByPayload<T extends ProdutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
        }
      >
    >


  export type ProdutoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaProdutoId?: boolean
    descricao?: boolean
    preco?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produtosDoCardapio?: boolean | Produto$produtosDoCardapioArgs<ExtArgs>
    ProdutosDoPedido?: boolean | Produto$ProdutosDoPedidoArgs<ExtArgs>
    categoriaProduto?: boolean | CategoriaProdutoDefaultArgs<ExtArgs>
    _count?: boolean | ProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type ProdutoSelectScalar = {
    id?: boolean
    categoriaProdutoId?: boolean
    descricao?: boolean
    preco?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProdutoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtosDoCardapio?: boolean | Produto$produtosDoCardapioArgs<ExtArgs>
    ProdutosDoPedido?: boolean | Produto$ProdutosDoPedidoArgs<ExtArgs>
    categoriaProduto?: boolean | CategoriaProdutoDefaultArgs<ExtArgs>
    _count?: boolean | ProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProdutoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Produto"
    objects: {
      produtosDoCardapio: Prisma.$ProdutosDoCardapioPayload<ExtArgs>[]
      ProdutosDoPedido: Prisma.$ProdutosDoPedidoPayload<ExtArgs>[]
      categoriaProduto: Prisma.$CategoriaProdutoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoriaProdutoId: number
      descricao: string
      preco: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["produto"]>
    composites: {}
  }


  type ProdutoGetPayload<S extends boolean | null | undefined | ProdutoDefaultArgs> = $Result.GetResult<Prisma.$ProdutoPayload, S>

  type ProdutoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProdutoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProdutoCountAggregateInputType | true
    }

  export interface ProdutoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Produto'], meta: { name: 'Produto' } }
    /**
     * Find zero or one Produto that matches the filter.
     * @param {ProdutoFindUniqueArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProdutoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutoFindUniqueArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Produto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProdutoFindUniqueOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProdutoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Produto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProdutoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutoFindFirstArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Produto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProdutoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produtos
     * const produtos = await prisma.produto.findMany()
     * 
     * // Get first 10 Produtos
     * const produtos = await prisma.produto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtoWithIdOnly = await prisma.produto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProdutoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Produto.
     * @param {ProdutoCreateArgs} args - Arguments to create a Produto.
     * @example
     * // Create one Produto
     * const Produto = await prisma.produto.create({
     *   data: {
     *     // ... data to create a Produto
     *   }
     * })
     * 
    **/
    create<T extends ProdutoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutoCreateArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Produtos.
     *     @param {ProdutoCreateManyArgs} args - Arguments to create many Produtos.
     *     @example
     *     // Create many Produtos
     *     const produto = await prisma.produto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProdutoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produto.
     * @param {ProdutoDeleteArgs} args - Arguments to delete one Produto.
     * @example
     * // Delete one Produto
     * const Produto = await prisma.produto.delete({
     *   where: {
     *     // ... filter to delete one Produto
     *   }
     * })
     * 
    **/
    delete<T extends ProdutoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutoDeleteArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Produto.
     * @param {ProdutoUpdateArgs} args - Arguments to update one Produto.
     * @example
     * // Update one Produto
     * const produto = await prisma.produto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProdutoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutoUpdateArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Produtos.
     * @param {ProdutoDeleteManyArgs} args - Arguments to filter Produtos to delete.
     * @example
     * // Delete a few Produtos
     * const { count } = await prisma.produto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProdutoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProdutoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produto.
     * @param {ProdutoUpsertArgs} args - Arguments to update or create a Produto.
     * @example
     * // Update or create a Produto
     * const produto = await prisma.produto.upsert({
     *   create: {
     *     // ... data to create a Produto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produto we want to update
     *   }
     * })
    **/
    upsert<T extends ProdutoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutoUpsertArgs<ExtArgs>>
    ): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoCountArgs} args - Arguments to filter Produtos to count.
     * @example
     * // Count the number of Produtos
     * const count = await prisma.produto.count({
     *   where: {
     *     // ... the filter for the Produtos we want to count
     *   }
     * })
    **/
    count<T extends ProdutoCountArgs>(
      args?: Subset<T, ProdutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutoAggregateArgs>(args: Subset<T, ProdutoAggregateArgs>): Prisma.PrismaPromise<GetProdutoAggregateType<T>>

    /**
     * Group by Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutoGroupByArgs['orderBy'] }
        : { orderBy?: ProdutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Produto model
   */
  readonly fields: ProdutoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Produto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdutoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produtosDoCardapio<T extends Produto$produtosDoCardapioArgs<ExtArgs> = {}>(args?: Subset<T, Produto$produtosDoCardapioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findMany'> | Null>;

    ProdutosDoPedido<T extends Produto$ProdutosDoPedidoArgs<ExtArgs> = {}>(args?: Subset<T, Produto$ProdutosDoPedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutosDoPedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    categoriaProduto<T extends CategoriaProdutoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaProdutoDefaultArgs<ExtArgs>>): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Produto model
   */ 
  interface ProdutoFieldRefs {
    readonly id: FieldRef<"Produto", 'Int'>
    readonly categoriaProdutoId: FieldRef<"Produto", 'Int'>
    readonly descricao: FieldRef<"Produto", 'String'>
    readonly preco: FieldRef<"Produto", 'Decimal'>
    readonly createdAt: FieldRef<"Produto", 'DateTime'>
    readonly updatedAt: FieldRef<"Produto", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Produto findUnique
   */
  export type ProdutoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }


  /**
   * Produto findUniqueOrThrow
   */
  export type ProdutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }


  /**
   * Produto findFirst
   */
  export type ProdutoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }


  /**
   * Produto findFirstOrThrow
   */
  export type ProdutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }


  /**
   * Produto findMany
   */
  export type ProdutoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produtos to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }


  /**
   * Produto create
   */
  export type ProdutoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to create a Produto.
     */
    data: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
  }


  /**
   * Produto createMany
   */
  export type ProdutoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Produtos.
     */
    data: ProdutoCreateManyInput | ProdutoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Produto update
   */
  export type ProdutoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to update a Produto.
     */
    data: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
    /**
     * Choose, which Produto to update.
     */
    where: ProdutoWhereUniqueInput
  }


  /**
   * Produto updateMany
   */
  export type ProdutoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Produtos.
     */
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyInput>
    /**
     * Filter which Produtos to update
     */
    where?: ProdutoWhereInput
  }


  /**
   * Produto upsert
   */
  export type ProdutoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The filter to search for the Produto to update in case it exists.
     */
    where: ProdutoWhereUniqueInput
    /**
     * In case the Produto found by the `where` argument doesn't exist, create a new Produto with this data.
     */
    create: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
    /**
     * In case the Produto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
  }


  /**
   * Produto delete
   */
  export type ProdutoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter which Produto to delete.
     */
    where: ProdutoWhereUniqueInput
  }


  /**
   * Produto deleteMany
   */
  export type ProdutoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produtos to delete
     */
    where?: ProdutoWhereInput
  }


  /**
   * Produto.produtosDoCardapio
   */
  export type Produto$produtosDoCardapioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    where?: ProdutosDoCardapioWhereInput
    orderBy?: ProdutosDoCardapioOrderByWithRelationInput | ProdutosDoCardapioOrderByWithRelationInput[]
    cursor?: ProdutosDoCardapioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutosDoCardapioScalarFieldEnum | ProdutosDoCardapioScalarFieldEnum[]
  }


  /**
   * Produto.ProdutosDoPedido
   */
  export type Produto$ProdutosDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoPedido
     */
    select?: ProdutosDoPedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoPedidoInclude<ExtArgs> | null
    where?: ProdutosDoPedidoWhereInput
    orderBy?: ProdutosDoPedidoOrderByWithRelationInput | ProdutosDoPedidoOrderByWithRelationInput[]
    cursor?: ProdutosDoPedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutosDoPedidoScalarFieldEnum | ProdutosDoPedidoScalarFieldEnum[]
  }


  /**
   * Produto without action
   */
  export type ProdutoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
  }



  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    id: number | null
    statusPagamentoId: number | null
    pedidoId: number | null
    valor: Decimal | null
  }

  export type PagamentoSumAggregateOutputType = {
    id: number | null
    statusPagamentoId: number | null
    pedidoId: number | null
    valor: Decimal | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: number | null
    statusPagamentoId: number | null
    pedidoId: number | null
    tipo: string | null
    data: Date | null
    valor: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: number | null
    statusPagamentoId: number | null
    pedidoId: number | null
    tipo: string | null
    data: Date | null
    valor: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    statusPagamentoId: number
    pedidoId: number
    tipo: number
    data: number
    valor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    id?: true
    statusPagamentoId?: true
    pedidoId?: true
    valor?: true
  }

  export type PagamentoSumAggregateInputType = {
    id?: true
    statusPagamentoId?: true
    pedidoId?: true
    valor?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    statusPagamentoId?: true
    pedidoId?: true
    tipo?: true
    data?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    statusPagamentoId?: true
    pedidoId?: true
    tipo?: true
    data?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    statusPagamentoId?: true
    pedidoId?: true
    tipo?: true
    data?: true
    valor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: number
    statusPagamentoId: number
    pedidoId: number
    tipo: string
    data: Date
    valor: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statusPagamentoId?: boolean
    pedidoId?: boolean
    tipo?: boolean
    data?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    statusPagamento?: boolean | StatusPagamentoDefaultArgs<ExtArgs>
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectScalar = {
    id?: boolean
    statusPagamentoId?: boolean
    pedidoId?: boolean
    tipo?: boolean
    data?: boolean
    valor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusPagamento?: boolean | StatusPagamentoDefaultArgs<ExtArgs>
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }


  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      statusPagamento: Prisma.$StatusPagamentoPayload<ExtArgs>
      pedido: Prisma.$PedidoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statusPagamentoId: number
      pedidoId: number
      tipo: string
      data: Date
      valor: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }


  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PagamentoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pagamento that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PagamentoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PagamentoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
    **/
    create<T extends PagamentoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pagamentos.
     *     @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     *     @example
     *     // Create many Pagamentos
     *     const pagamento = await prisma.pagamento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PagamentoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
    **/
    delete<T extends PagamentoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PagamentoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PagamentoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PagamentoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
    **/
    upsert<T extends PagamentoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>
    ): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    statusPagamento<T extends StatusPagamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatusPagamentoDefaultArgs<ExtArgs>>): Prisma__StatusPagamentoClient<$Result.GetResult<Prisma.$StatusPagamentoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Pagamento model
   */ 
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'Int'>
    readonly statusPagamentoId: FieldRef<"Pagamento", 'Int'>
    readonly pedidoId: FieldRef<"Pagamento", 'Int'>
    readonly tipo: FieldRef<"Pagamento", 'String'>
    readonly data: FieldRef<"Pagamento", 'DateTime'>
    readonly valor: FieldRef<"Pagamento", 'Decimal'>
    readonly createdAt: FieldRef<"Pagamento", 'DateTime'>
    readonly updatedAt: FieldRef<"Pagamento", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }


  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }


  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }


  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }


  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }


  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }


  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }


  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
  }


  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }


  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }


  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
  }


  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PagamentoInclude<ExtArgs> | null
  }



  /**
   * Model CategoriaProduto
   */

  export type AggregateCategoriaProduto = {
    _count: CategoriaProdutoCountAggregateOutputType | null
    _avg: CategoriaProdutoAvgAggregateOutputType | null
    _sum: CategoriaProdutoSumAggregateOutputType | null
    _min: CategoriaProdutoMinAggregateOutputType | null
    _max: CategoriaProdutoMaxAggregateOutputType | null
  }

  export type CategoriaProdutoAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaProdutoSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaProdutoMinAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriaProdutoMaxAggregateOutputType = {
    id: number | null
    enumerador: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriaProdutoCountAggregateOutputType = {
    id: number
    enumerador: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoriaProdutoAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaProdutoSumAggregateInputType = {
    id?: true
  }

  export type CategoriaProdutoMinAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriaProdutoMaxAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriaProdutoCountAggregateInputType = {
    id?: true
    enumerador?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoriaProdutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriaProduto to aggregate.
     */
    where?: CategoriaProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaProdutos to fetch.
     */
    orderBy?: CategoriaProdutoOrderByWithRelationInput | CategoriaProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaProdutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaProdutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoriaProdutos
    **/
    _count?: true | CategoriaProdutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaProdutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaProdutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaProdutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaProdutoMaxAggregateInputType
  }

  export type GetCategoriaProdutoAggregateType<T extends CategoriaProdutoAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriaProduto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriaProduto[P]>
      : GetScalarType<T[P], AggregateCategoriaProduto[P]>
  }




  export type CategoriaProdutoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaProdutoWhereInput
    orderBy?: CategoriaProdutoOrderByWithAggregationInput | CategoriaProdutoOrderByWithAggregationInput[]
    by: CategoriaProdutoScalarFieldEnum[] | CategoriaProdutoScalarFieldEnum
    having?: CategoriaProdutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaProdutoCountAggregateInputType | true
    _avg?: CategoriaProdutoAvgAggregateInputType
    _sum?: CategoriaProdutoSumAggregateInputType
    _min?: CategoriaProdutoMinAggregateInputType
    _max?: CategoriaProdutoMaxAggregateInputType
  }

  export type CategoriaProdutoGroupByOutputType = {
    id: number
    enumerador: string
    createdAt: Date
    updatedAt: Date
    _count: CategoriaProdutoCountAggregateOutputType | null
    _avg: CategoriaProdutoAvgAggregateOutputType | null
    _sum: CategoriaProdutoSumAggregateOutputType | null
    _min: CategoriaProdutoMinAggregateOutputType | null
    _max: CategoriaProdutoMaxAggregateOutputType | null
  }

  type GetCategoriaProdutoGroupByPayload<T extends CategoriaProdutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaProdutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaProdutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaProdutoGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaProdutoGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaProdutoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produto?: boolean | CategoriaProduto$produtoArgs<ExtArgs>
    _count?: boolean | CategoriaProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriaProduto"]>

  export type CategoriaProdutoSelectScalar = {
    id?: boolean
    enumerador?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoriaProdutoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produto?: boolean | CategoriaProduto$produtoArgs<ExtArgs>
    _count?: boolean | CategoriaProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoriaProdutoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoriaProduto"
    objects: {
      produto: Prisma.$ProdutoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enumerador: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoriaProduto"]>
    composites: {}
  }


  type CategoriaProdutoGetPayload<S extends boolean | null | undefined | CategoriaProdutoDefaultArgs> = $Result.GetResult<Prisma.$CategoriaProdutoPayload, S>

  type CategoriaProdutoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriaProdutoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriaProdutoCountAggregateInputType | true
    }

  export interface CategoriaProdutoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoriaProduto'], meta: { name: 'CategoriaProduto' } }
    /**
     * Find zero or one CategoriaProduto that matches the filter.
     * @param {CategoriaProdutoFindUniqueArgs} args - Arguments to find a CategoriaProduto
     * @example
     * // Get one CategoriaProduto
     * const categoriaProduto = await prisma.categoriaProduto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaProdutoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaProdutoFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CategoriaProduto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoriaProdutoFindUniqueOrThrowArgs} args - Arguments to find a CategoriaProduto
     * @example
     * // Get one CategoriaProduto
     * const categoriaProduto = await prisma.categoriaProduto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriaProdutoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaProdutoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CategoriaProduto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoFindFirstArgs} args - Arguments to find a CategoriaProduto
     * @example
     * // Get one CategoriaProduto
     * const categoriaProduto = await prisma.categoriaProduto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaProdutoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaProdutoFindFirstArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CategoriaProduto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoFindFirstOrThrowArgs} args - Arguments to find a CategoriaProduto
     * @example
     * // Get one CategoriaProduto
     * const categoriaProduto = await prisma.categoriaProduto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriaProdutoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaProdutoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CategoriaProdutos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriaProdutos
     * const categoriaProdutos = await prisma.categoriaProduto.findMany()
     * 
     * // Get first 10 CategoriaProdutos
     * const categoriaProdutos = await prisma.categoriaProduto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaProdutoWithIdOnly = await prisma.categoriaProduto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriaProdutoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaProdutoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CategoriaProduto.
     * @param {CategoriaProdutoCreateArgs} args - Arguments to create a CategoriaProduto.
     * @example
     * // Create one CategoriaProduto
     * const CategoriaProduto = await prisma.categoriaProduto.create({
     *   data: {
     *     // ... data to create a CategoriaProduto
     *   }
     * })
     * 
    **/
    create<T extends CategoriaProdutoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaProdutoCreateArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CategoriaProdutos.
     *     @param {CategoriaProdutoCreateManyArgs} args - Arguments to create many CategoriaProdutos.
     *     @example
     *     // Create many CategoriaProdutos
     *     const categoriaProduto = await prisma.categoriaProduto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaProdutoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaProdutoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoriaProduto.
     * @param {CategoriaProdutoDeleteArgs} args - Arguments to delete one CategoriaProduto.
     * @example
     * // Delete one CategoriaProduto
     * const CategoriaProduto = await prisma.categoriaProduto.delete({
     *   where: {
     *     // ... filter to delete one CategoriaProduto
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaProdutoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaProdutoDeleteArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CategoriaProduto.
     * @param {CategoriaProdutoUpdateArgs} args - Arguments to update one CategoriaProduto.
     * @example
     * // Update one CategoriaProduto
     * const categoriaProduto = await prisma.categoriaProduto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaProdutoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaProdutoUpdateArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CategoriaProdutos.
     * @param {CategoriaProdutoDeleteManyArgs} args - Arguments to filter CategoriaProdutos to delete.
     * @example
     * // Delete a few CategoriaProdutos
     * const { count } = await prisma.categoriaProduto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaProdutoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaProdutoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriaProdutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriaProdutos
     * const categoriaProduto = await prisma.categoriaProduto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaProdutoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaProdutoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoriaProduto.
     * @param {CategoriaProdutoUpsertArgs} args - Arguments to update or create a CategoriaProduto.
     * @example
     * // Update or create a CategoriaProduto
     * const categoriaProduto = await prisma.categoriaProduto.upsert({
     *   create: {
     *     // ... data to create a CategoriaProduto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriaProduto we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaProdutoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaProdutoUpsertArgs<ExtArgs>>
    ): Prisma__CategoriaProdutoClient<$Result.GetResult<Prisma.$CategoriaProdutoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CategoriaProdutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoCountArgs} args - Arguments to filter CategoriaProdutos to count.
     * @example
     * // Count the number of CategoriaProdutos
     * const count = await prisma.categoriaProduto.count({
     *   where: {
     *     // ... the filter for the CategoriaProdutos we want to count
     *   }
     * })
    **/
    count<T extends CategoriaProdutoCountArgs>(
      args?: Subset<T, CategoriaProdutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaProdutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriaProduto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaProdutoAggregateArgs>(args: Subset<T, CategoriaProdutoAggregateArgs>): Prisma.PrismaPromise<GetCategoriaProdutoAggregateType<T>>

    /**
     * Group by CategoriaProduto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaProdutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaProdutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaProdutoGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaProdutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaProdutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaProdutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoriaProduto model
   */
  readonly fields: CategoriaProdutoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoriaProduto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaProdutoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produto<T extends CategoriaProduto$produtoArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaProduto$produtoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CategoriaProduto model
   */ 
  interface CategoriaProdutoFieldRefs {
    readonly id: FieldRef<"CategoriaProduto", 'Int'>
    readonly enumerador: FieldRef<"CategoriaProduto", 'String'>
    readonly createdAt: FieldRef<"CategoriaProduto", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoriaProduto", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CategoriaProduto findUnique
   */
  export type CategoriaProdutoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaProduto to fetch.
     */
    where: CategoriaProdutoWhereUniqueInput
  }


  /**
   * CategoriaProduto findUniqueOrThrow
   */
  export type CategoriaProdutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaProduto to fetch.
     */
    where: CategoriaProdutoWhereUniqueInput
  }


  /**
   * CategoriaProduto findFirst
   */
  export type CategoriaProdutoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaProduto to fetch.
     */
    where?: CategoriaProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaProdutos to fetch.
     */
    orderBy?: CategoriaProdutoOrderByWithRelationInput | CategoriaProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriaProdutos.
     */
    cursor?: CategoriaProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaProdutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaProdutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriaProdutos.
     */
    distinct?: CategoriaProdutoScalarFieldEnum | CategoriaProdutoScalarFieldEnum[]
  }


  /**
   * CategoriaProduto findFirstOrThrow
   */
  export type CategoriaProdutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaProduto to fetch.
     */
    where?: CategoriaProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaProdutos to fetch.
     */
    orderBy?: CategoriaProdutoOrderByWithRelationInput | CategoriaProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriaProdutos.
     */
    cursor?: CategoriaProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaProdutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaProdutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriaProdutos.
     */
    distinct?: CategoriaProdutoScalarFieldEnum | CategoriaProdutoScalarFieldEnum[]
  }


  /**
   * CategoriaProduto findMany
   */
  export type CategoriaProdutoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaProdutos to fetch.
     */
    where?: CategoriaProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaProdutos to fetch.
     */
    orderBy?: CategoriaProdutoOrderByWithRelationInput | CategoriaProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoriaProdutos.
     */
    cursor?: CategoriaProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaProdutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaProdutos.
     */
    skip?: number
    distinct?: CategoriaProdutoScalarFieldEnum | CategoriaProdutoScalarFieldEnum[]
  }


  /**
   * CategoriaProduto create
   */
  export type CategoriaProdutoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoriaProduto.
     */
    data: XOR<CategoriaProdutoCreateInput, CategoriaProdutoUncheckedCreateInput>
  }


  /**
   * CategoriaProduto createMany
   */
  export type CategoriaProdutoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoriaProdutos.
     */
    data: CategoriaProdutoCreateManyInput | CategoriaProdutoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CategoriaProduto update
   */
  export type CategoriaProdutoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoriaProduto.
     */
    data: XOR<CategoriaProdutoUpdateInput, CategoriaProdutoUncheckedUpdateInput>
    /**
     * Choose, which CategoriaProduto to update.
     */
    where: CategoriaProdutoWhereUniqueInput
  }


  /**
   * CategoriaProduto updateMany
   */
  export type CategoriaProdutoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoriaProdutos.
     */
    data: XOR<CategoriaProdutoUpdateManyMutationInput, CategoriaProdutoUncheckedUpdateManyInput>
    /**
     * Filter which CategoriaProdutos to update
     */
    where?: CategoriaProdutoWhereInput
  }


  /**
   * CategoriaProduto upsert
   */
  export type CategoriaProdutoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoriaProduto to update in case it exists.
     */
    where: CategoriaProdutoWhereUniqueInput
    /**
     * In case the CategoriaProduto found by the `where` argument doesn't exist, create a new CategoriaProduto with this data.
     */
    create: XOR<CategoriaProdutoCreateInput, CategoriaProdutoUncheckedCreateInput>
    /**
     * In case the CategoriaProduto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaProdutoUpdateInput, CategoriaProdutoUncheckedUpdateInput>
  }


  /**
   * CategoriaProduto delete
   */
  export type CategoriaProdutoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
    /**
     * Filter which CategoriaProduto to delete.
     */
    where: CategoriaProdutoWhereUniqueInput
  }


  /**
   * CategoriaProduto deleteMany
   */
  export type CategoriaProdutoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriaProdutos to delete
     */
    where?: CategoriaProdutoWhereInput
  }


  /**
   * CategoriaProduto.produto
   */
  export type CategoriaProduto$produtoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutoInclude<ExtArgs> | null
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    cursor?: ProdutoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }


  /**
   * CategoriaProduto without action
   */
  export type CategoriaProdutoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaProduto
     */
    select?: CategoriaProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaProdutoInclude<ExtArgs> | null
  }



  /**
   * Model ProdutosDoCardapio
   */

  export type AggregateProdutosDoCardapio = {
    _count: ProdutosDoCardapioCountAggregateOutputType | null
    _avg: ProdutosDoCardapioAvgAggregateOutputType | null
    _sum: ProdutosDoCardapioSumAggregateOutputType | null
    _min: ProdutosDoCardapioMinAggregateOutputType | null
    _max: ProdutosDoCardapioMaxAggregateOutputType | null
  }

  export type ProdutosDoCardapioAvgAggregateOutputType = {
    id: number | null
    produtoId: number | null
    cardapioId: number | null
  }

  export type ProdutosDoCardapioSumAggregateOutputType = {
    id: number | null
    produtoId: number | null
    cardapioId: number | null
  }

  export type ProdutosDoCardapioMinAggregateOutputType = {
    id: number | null
    produtoId: number | null
    cardapioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProdutosDoCardapioMaxAggregateOutputType = {
    id: number | null
    produtoId: number | null
    cardapioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProdutosDoCardapioCountAggregateOutputType = {
    id: number
    produtoId: number
    cardapioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProdutosDoCardapioAvgAggregateInputType = {
    id?: true
    produtoId?: true
    cardapioId?: true
  }

  export type ProdutosDoCardapioSumAggregateInputType = {
    id?: true
    produtoId?: true
    cardapioId?: true
  }

  export type ProdutosDoCardapioMinAggregateInputType = {
    id?: true
    produtoId?: true
    cardapioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProdutosDoCardapioMaxAggregateInputType = {
    id?: true
    produtoId?: true
    cardapioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProdutosDoCardapioCountAggregateInputType = {
    id?: true
    produtoId?: true
    cardapioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProdutosDoCardapioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProdutosDoCardapio to aggregate.
     */
    where?: ProdutosDoCardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoCardapios to fetch.
     */
    orderBy?: ProdutosDoCardapioOrderByWithRelationInput | ProdutosDoCardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdutosDoCardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoCardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoCardapios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProdutosDoCardapios
    **/
    _count?: true | ProdutosDoCardapioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutosDoCardapioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutosDoCardapioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutosDoCardapioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutosDoCardapioMaxAggregateInputType
  }

  export type GetProdutosDoCardapioAggregateType<T extends ProdutosDoCardapioAggregateArgs> = {
        [P in keyof T & keyof AggregateProdutosDoCardapio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProdutosDoCardapio[P]>
      : GetScalarType<T[P], AggregateProdutosDoCardapio[P]>
  }




  export type ProdutosDoCardapioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutosDoCardapioWhereInput
    orderBy?: ProdutosDoCardapioOrderByWithAggregationInput | ProdutosDoCardapioOrderByWithAggregationInput[]
    by: ProdutosDoCardapioScalarFieldEnum[] | ProdutosDoCardapioScalarFieldEnum
    having?: ProdutosDoCardapioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutosDoCardapioCountAggregateInputType | true
    _avg?: ProdutosDoCardapioAvgAggregateInputType
    _sum?: ProdutosDoCardapioSumAggregateInputType
    _min?: ProdutosDoCardapioMinAggregateInputType
    _max?: ProdutosDoCardapioMaxAggregateInputType
  }

  export type ProdutosDoCardapioGroupByOutputType = {
    id: number
    produtoId: number
    cardapioId: number
    createdAt: Date
    updatedAt: Date
    _count: ProdutosDoCardapioCountAggregateOutputType | null
    _avg: ProdutosDoCardapioAvgAggregateOutputType | null
    _sum: ProdutosDoCardapioSumAggregateOutputType | null
    _min: ProdutosDoCardapioMinAggregateOutputType | null
    _max: ProdutosDoCardapioMaxAggregateOutputType | null
  }

  type GetProdutosDoCardapioGroupByPayload<T extends ProdutosDoCardapioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutosDoCardapioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutosDoCardapioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutosDoCardapioGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutosDoCardapioGroupByOutputType[P]>
        }
      >
    >


  export type ProdutosDoCardapioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produtoId?: boolean
    cardapioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    cardapio?: boolean | CardapioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produtosDoCardapio"]>

  export type ProdutosDoCardapioSelectScalar = {
    id?: boolean
    produtoId?: boolean
    cardapioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProdutosDoCardapioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    cardapio?: boolean | CardapioDefaultArgs<ExtArgs>
  }


  export type $ProdutosDoCardapioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProdutosDoCardapio"
    objects: {
      produto: Prisma.$ProdutoPayload<ExtArgs>
      cardapio: Prisma.$CardapioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      produtoId: number
      cardapioId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["produtosDoCardapio"]>
    composites: {}
  }


  type ProdutosDoCardapioGetPayload<S extends boolean | null | undefined | ProdutosDoCardapioDefaultArgs> = $Result.GetResult<Prisma.$ProdutosDoCardapioPayload, S>

  type ProdutosDoCardapioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProdutosDoCardapioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProdutosDoCardapioCountAggregateInputType | true
    }

  export interface ProdutosDoCardapioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProdutosDoCardapio'], meta: { name: 'ProdutosDoCardapio' } }
    /**
     * Find zero or one ProdutosDoCardapio that matches the filter.
     * @param {ProdutosDoCardapioFindUniqueArgs} args - Arguments to find a ProdutosDoCardapio
     * @example
     * // Get one ProdutosDoCardapio
     * const produtosDoCardapio = await prisma.produtosDoCardapio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProdutosDoCardapioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoCardapioFindUniqueArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProdutosDoCardapio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProdutosDoCardapioFindUniqueOrThrowArgs} args - Arguments to find a ProdutosDoCardapio
     * @example
     * // Get one ProdutosDoCardapio
     * const produtosDoCardapio = await prisma.produtosDoCardapio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProdutosDoCardapioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoCardapioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProdutosDoCardapio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioFindFirstArgs} args - Arguments to find a ProdutosDoCardapio
     * @example
     * // Get one ProdutosDoCardapio
     * const produtosDoCardapio = await prisma.produtosDoCardapio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProdutosDoCardapioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoCardapioFindFirstArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProdutosDoCardapio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioFindFirstOrThrowArgs} args - Arguments to find a ProdutosDoCardapio
     * @example
     * // Get one ProdutosDoCardapio
     * const produtosDoCardapio = await prisma.produtosDoCardapio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProdutosDoCardapioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoCardapioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProdutosDoCardapios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProdutosDoCardapios
     * const produtosDoCardapios = await prisma.produtosDoCardapio.findMany()
     * 
     * // Get first 10 ProdutosDoCardapios
     * const produtosDoCardapios = await prisma.produtosDoCardapio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtosDoCardapioWithIdOnly = await prisma.produtosDoCardapio.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProdutosDoCardapioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoCardapioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProdutosDoCardapio.
     * @param {ProdutosDoCardapioCreateArgs} args - Arguments to create a ProdutosDoCardapio.
     * @example
     * // Create one ProdutosDoCardapio
     * const ProdutosDoCardapio = await prisma.produtosDoCardapio.create({
     *   data: {
     *     // ... data to create a ProdutosDoCardapio
     *   }
     * })
     * 
    **/
    create<T extends ProdutosDoCardapioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoCardapioCreateArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProdutosDoCardapios.
     *     @param {ProdutosDoCardapioCreateManyArgs} args - Arguments to create many ProdutosDoCardapios.
     *     @example
     *     // Create many ProdutosDoCardapios
     *     const produtosDoCardapio = await prisma.produtosDoCardapio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProdutosDoCardapioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoCardapioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProdutosDoCardapio.
     * @param {ProdutosDoCardapioDeleteArgs} args - Arguments to delete one ProdutosDoCardapio.
     * @example
     * // Delete one ProdutosDoCardapio
     * const ProdutosDoCardapio = await prisma.produtosDoCardapio.delete({
     *   where: {
     *     // ... filter to delete one ProdutosDoCardapio
     *   }
     * })
     * 
    **/
    delete<T extends ProdutosDoCardapioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoCardapioDeleteArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProdutosDoCardapio.
     * @param {ProdutosDoCardapioUpdateArgs} args - Arguments to update one ProdutosDoCardapio.
     * @example
     * // Update one ProdutosDoCardapio
     * const produtosDoCardapio = await prisma.produtosDoCardapio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProdutosDoCardapioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoCardapioUpdateArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProdutosDoCardapios.
     * @param {ProdutosDoCardapioDeleteManyArgs} args - Arguments to filter ProdutosDoCardapios to delete.
     * @example
     * // Delete a few ProdutosDoCardapios
     * const { count } = await prisma.produtosDoCardapio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProdutosDoCardapioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProdutosDoCardapioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProdutosDoCardapios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProdutosDoCardapios
     * const produtosDoCardapio = await prisma.produtosDoCardapio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProdutosDoCardapioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoCardapioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProdutosDoCardapio.
     * @param {ProdutosDoCardapioUpsertArgs} args - Arguments to update or create a ProdutosDoCardapio.
     * @example
     * // Update or create a ProdutosDoCardapio
     * const produtosDoCardapio = await prisma.produtosDoCardapio.upsert({
     *   create: {
     *     // ... data to create a ProdutosDoCardapio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProdutosDoCardapio we want to update
     *   }
     * })
    **/
    upsert<T extends ProdutosDoCardapioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProdutosDoCardapioUpsertArgs<ExtArgs>>
    ): Prisma__ProdutosDoCardapioClient<$Result.GetResult<Prisma.$ProdutosDoCardapioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProdutosDoCardapios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioCountArgs} args - Arguments to filter ProdutosDoCardapios to count.
     * @example
     * // Count the number of ProdutosDoCardapios
     * const count = await prisma.produtosDoCardapio.count({
     *   where: {
     *     // ... the filter for the ProdutosDoCardapios we want to count
     *   }
     * })
    **/
    count<T extends ProdutosDoCardapioCountArgs>(
      args?: Subset<T, ProdutosDoCardapioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutosDoCardapioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProdutosDoCardapio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutosDoCardapioAggregateArgs>(args: Subset<T, ProdutosDoCardapioAggregateArgs>): Prisma.PrismaPromise<GetProdutosDoCardapioAggregateType<T>>

    /**
     * Group by ProdutosDoCardapio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosDoCardapioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutosDoCardapioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutosDoCardapioGroupByArgs['orderBy'] }
        : { orderBy?: ProdutosDoCardapioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutosDoCardapioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutosDoCardapioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProdutosDoCardapio model
   */
  readonly fields: ProdutosDoCardapioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProdutosDoCardapio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdutosDoCardapioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    produto<T extends ProdutoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProdutoDefaultArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cardapio<T extends CardapioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardapioDefaultArgs<ExtArgs>>): Prisma__CardapioClient<$Result.GetResult<Prisma.$CardapioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProdutosDoCardapio model
   */ 
  interface ProdutosDoCardapioFieldRefs {
    readonly id: FieldRef<"ProdutosDoCardapio", 'Int'>
    readonly produtoId: FieldRef<"ProdutosDoCardapio", 'Int'>
    readonly cardapioId: FieldRef<"ProdutosDoCardapio", 'Int'>
    readonly createdAt: FieldRef<"ProdutosDoCardapio", 'DateTime'>
    readonly updatedAt: FieldRef<"ProdutosDoCardapio", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ProdutosDoCardapio findUnique
   */
  export type ProdutosDoCardapioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoCardapio to fetch.
     */
    where: ProdutosDoCardapioWhereUniqueInput
  }


  /**
   * ProdutosDoCardapio findUniqueOrThrow
   */
  export type ProdutosDoCardapioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoCardapio to fetch.
     */
    where: ProdutosDoCardapioWhereUniqueInput
  }


  /**
   * ProdutosDoCardapio findFirst
   */
  export type ProdutosDoCardapioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoCardapio to fetch.
     */
    where?: ProdutosDoCardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoCardapios to fetch.
     */
    orderBy?: ProdutosDoCardapioOrderByWithRelationInput | ProdutosDoCardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProdutosDoCardapios.
     */
    cursor?: ProdutosDoCardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoCardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoCardapios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProdutosDoCardapios.
     */
    distinct?: ProdutosDoCardapioScalarFieldEnum | ProdutosDoCardapioScalarFieldEnum[]
  }


  /**
   * ProdutosDoCardapio findFirstOrThrow
   */
  export type ProdutosDoCardapioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoCardapio to fetch.
     */
    where?: ProdutosDoCardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoCardapios to fetch.
     */
    orderBy?: ProdutosDoCardapioOrderByWithRelationInput | ProdutosDoCardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProdutosDoCardapios.
     */
    cursor?: ProdutosDoCardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoCardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoCardapios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProdutosDoCardapios.
     */
    distinct?: ProdutosDoCardapioScalarFieldEnum | ProdutosDoCardapioScalarFieldEnum[]
  }


  /**
   * ProdutosDoCardapio findMany
   */
  export type ProdutosDoCardapioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * Filter, which ProdutosDoCardapios to fetch.
     */
    where?: ProdutosDoCardapioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdutosDoCardapios to fetch.
     */
    orderBy?: ProdutosDoCardapioOrderByWithRelationInput | ProdutosDoCardapioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProdutosDoCardapios.
     */
    cursor?: ProdutosDoCardapioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdutosDoCardapios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdutosDoCardapios.
     */
    skip?: number
    distinct?: ProdutosDoCardapioScalarFieldEnum | ProdutosDoCardapioScalarFieldEnum[]
  }


  /**
   * ProdutosDoCardapio create
   */
  export type ProdutosDoCardapioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * The data needed to create a ProdutosDoCardapio.
     */
    data: XOR<ProdutosDoCardapioCreateInput, ProdutosDoCardapioUncheckedCreateInput>
  }


  /**
   * ProdutosDoCardapio createMany
   */
  export type ProdutosDoCardapioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProdutosDoCardapios.
     */
    data: ProdutosDoCardapioCreateManyInput | ProdutosDoCardapioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProdutosDoCardapio update
   */
  export type ProdutosDoCardapioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * The data needed to update a ProdutosDoCardapio.
     */
    data: XOR<ProdutosDoCardapioUpdateInput, ProdutosDoCardapioUncheckedUpdateInput>
    /**
     * Choose, which ProdutosDoCardapio to update.
     */
    where: ProdutosDoCardapioWhereUniqueInput
  }


  /**
   * ProdutosDoCardapio updateMany
   */
  export type ProdutosDoCardapioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProdutosDoCardapios.
     */
    data: XOR<ProdutosDoCardapioUpdateManyMutationInput, ProdutosDoCardapioUncheckedUpdateManyInput>
    /**
     * Filter which ProdutosDoCardapios to update
     */
    where?: ProdutosDoCardapioWhereInput
  }


  /**
   * ProdutosDoCardapio upsert
   */
  export type ProdutosDoCardapioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * The filter to search for the ProdutosDoCardapio to update in case it exists.
     */
    where: ProdutosDoCardapioWhereUniqueInput
    /**
     * In case the ProdutosDoCardapio found by the `where` argument doesn't exist, create a new ProdutosDoCardapio with this data.
     */
    create: XOR<ProdutosDoCardapioCreateInput, ProdutosDoCardapioUncheckedCreateInput>
    /**
     * In case the ProdutosDoCardapio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdutosDoCardapioUpdateInput, ProdutosDoCardapioUncheckedUpdateInput>
  }


  /**
   * ProdutosDoCardapio delete
   */
  export type ProdutosDoCardapioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
    /**
     * Filter which ProdutosDoCardapio to delete.
     */
    where: ProdutosDoCardapioWhereUniqueInput
  }


  /**
   * ProdutosDoCardapio deleteMany
   */
  export type ProdutosDoCardapioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProdutosDoCardapios to delete
     */
    where?: ProdutosDoCardapioWhereInput
  }


  /**
   * ProdutosDoCardapio without action
   */
  export type ProdutosDoCardapioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutosDoCardapio
     */
    select?: ProdutosDoCardapioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProdutosDoCardapioInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nome: 'nome',
    email: 'email',
    cpf: 'cpf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const TipoAcessoScalarFieldEnum: {
    id: 'id',
    enumerador: 'enumerador',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TipoAcessoScalarFieldEnum = (typeof TipoAcessoScalarFieldEnum)[keyof typeof TipoAcessoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    tipoAcesso: 'tipoAcesso',
    login: 'login',
    senha: 'senha',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const FuncionarioScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nome: 'nome',
    cargo: 'cargo',
    admin: 'admin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FuncionarioScalarFieldEnum = (typeof FuncionarioScalarFieldEnum)[keyof typeof FuncionarioScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    clienteId: 'clienteId',
    statusPedidoId: 'statusPedidoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const StatusPedidoScalarFieldEnum: {
    id: 'id',
    enumerador: 'enumerador',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatusPedidoScalarFieldEnum = (typeof StatusPedidoScalarFieldEnum)[keyof typeof StatusPedidoScalarFieldEnum]


  export const StatusPagamentoScalarFieldEnum: {
    id: 'id',
    enumerador: 'enumerador',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatusPagamentoScalarFieldEnum = (typeof StatusPagamentoScalarFieldEnum)[keyof typeof StatusPagamentoScalarFieldEnum]


  export const CardapioScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardapioScalarFieldEnum = (typeof CardapioScalarFieldEnum)[keyof typeof CardapioScalarFieldEnum]


  export const ProdutosDoPedidoScalarFieldEnum: {
    id: 'id',
    produtoId: 'produtoId',
    pedidoId: 'pedidoId',
    quantidade: 'quantidade',
    valor: 'valor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProdutosDoPedidoScalarFieldEnum = (typeof ProdutosDoPedidoScalarFieldEnum)[keyof typeof ProdutosDoPedidoScalarFieldEnum]


  export const ProdutoScalarFieldEnum: {
    id: 'id',
    categoriaProdutoId: 'categoriaProdutoId',
    descricao: 'descricao',
    preco: 'preco',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProdutoScalarFieldEnum = (typeof ProdutoScalarFieldEnum)[keyof typeof ProdutoScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    statusPagamentoId: 'statusPagamentoId',
    pedidoId: 'pedidoId',
    tipo: 'tipo',
    data: 'data',
    valor: 'valor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const CategoriaProdutoScalarFieldEnum: {
    id: 'id',
    enumerador: 'enumerador',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoriaProdutoScalarFieldEnum = (typeof CategoriaProdutoScalarFieldEnum)[keyof typeof CategoriaProdutoScalarFieldEnum]


  export const ProdutosDoCardapioScalarFieldEnum: {
    id: 'id',
    produtoId: 'produtoId',
    cardapioId: 'cardapioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProdutosDoCardapioScalarFieldEnum = (typeof ProdutosDoCardapioScalarFieldEnum)[keyof typeof ProdutosDoCardapioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    usuarioId?: IntFilter<"Cliente"> | number
    nome?: StringNullableFilter<"Cliente"> | string | null
    email?: StringFilter<"Cliente"> | string
    cpf?: StringFilter<"Cliente"> | string
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    pedido?: PedidoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrderInput | SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    pedido?: PedidoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuarioId?: number
    email?: string
    cpf?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nome?: StringNullableFilter<"Cliente"> | string | null
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    pedido?: PedidoListRelationFilter
  }, "id" | "usuarioId" | "email" | "cpf">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrderInput | SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
    usuarioId?: IntWithAggregatesFilter<"Cliente"> | number
    nome?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    email?: StringWithAggregatesFilter<"Cliente"> | string
    cpf?: StringWithAggregatesFilter<"Cliente"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
  }

  export type TipoAcessoWhereInput = {
    AND?: TipoAcessoWhereInput | TipoAcessoWhereInput[]
    OR?: TipoAcessoWhereInput[]
    NOT?: TipoAcessoWhereInput | TipoAcessoWhereInput[]
    id?: IntFilter<"TipoAcesso"> | number
    enumerador?: StringFilter<"TipoAcesso"> | string
    createdAt?: DateTimeFilter<"TipoAcesso"> | Date | string
    updatedAt?: DateTimeFilter<"TipoAcesso"> | Date | string
  }

  export type TipoAcessoOrderByWithRelationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoAcessoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enumerador?: string
    AND?: TipoAcessoWhereInput | TipoAcessoWhereInput[]
    OR?: TipoAcessoWhereInput[]
    NOT?: TipoAcessoWhereInput | TipoAcessoWhereInput[]
    createdAt?: DateTimeFilter<"TipoAcesso"> | Date | string
    updatedAt?: DateTimeFilter<"TipoAcesso"> | Date | string
  }, "id" | "enumerador">

  export type TipoAcessoOrderByWithAggregationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TipoAcessoCountOrderByAggregateInput
    _avg?: TipoAcessoAvgOrderByAggregateInput
    _max?: TipoAcessoMaxOrderByAggregateInput
    _min?: TipoAcessoMinOrderByAggregateInput
    _sum?: TipoAcessoSumOrderByAggregateInput
  }

  export type TipoAcessoScalarWhereWithAggregatesInput = {
    AND?: TipoAcessoScalarWhereWithAggregatesInput | TipoAcessoScalarWhereWithAggregatesInput[]
    OR?: TipoAcessoScalarWhereWithAggregatesInput[]
    NOT?: TipoAcessoScalarWhereWithAggregatesInput | TipoAcessoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoAcesso"> | number
    enumerador?: StringWithAggregatesFilter<"TipoAcesso"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TipoAcesso"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TipoAcesso"> | Date | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    tipoAcesso?: StringFilter<"Usuario"> | string
    login?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    funcionario?: XOR<FuncionarioNullableRelationFilter, FuncionarioWhereInput> | null
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    tipoAcesso?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funcionario?: FuncionarioOrderByWithRelationInput
    cliente?: ClienteOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    login?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    tipoAcesso?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    funcionario?: XOR<FuncionarioNullableRelationFilter, FuncionarioWhereInput> | null
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
  }, "id" | "login">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    tipoAcesso?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    tipoAcesso?: StringWithAggregatesFilter<"Usuario"> | string
    login?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type FuncionarioWhereInput = {
    AND?: FuncionarioWhereInput | FuncionarioWhereInput[]
    OR?: FuncionarioWhereInput[]
    NOT?: FuncionarioWhereInput | FuncionarioWhereInput[]
    id?: IntFilter<"Funcionario"> | number
    usuarioId?: IntFilter<"Funcionario"> | number
    nome?: StringFilter<"Funcionario"> | string
    cargo?: StringFilter<"Funcionario"> | string
    admin?: StringFilter<"Funcionario"> | string
    createdAt?: DateTimeFilter<"Funcionario"> | Date | string
    updatedAt?: DateTimeFilter<"Funcionario"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type FuncionarioOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    cargo?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type FuncionarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuarioId?: number
    AND?: FuncionarioWhereInput | FuncionarioWhereInput[]
    OR?: FuncionarioWhereInput[]
    NOT?: FuncionarioWhereInput | FuncionarioWhereInput[]
    nome?: StringFilter<"Funcionario"> | string
    cargo?: StringFilter<"Funcionario"> | string
    admin?: StringFilter<"Funcionario"> | string
    createdAt?: DateTimeFilter<"Funcionario"> | Date | string
    updatedAt?: DateTimeFilter<"Funcionario"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "usuarioId">

  export type FuncionarioOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    cargo?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FuncionarioCountOrderByAggregateInput
    _avg?: FuncionarioAvgOrderByAggregateInput
    _max?: FuncionarioMaxOrderByAggregateInput
    _min?: FuncionarioMinOrderByAggregateInput
    _sum?: FuncionarioSumOrderByAggregateInput
  }

  export type FuncionarioScalarWhereWithAggregatesInput = {
    AND?: FuncionarioScalarWhereWithAggregatesInput | FuncionarioScalarWhereWithAggregatesInput[]
    OR?: FuncionarioScalarWhereWithAggregatesInput[]
    NOT?: FuncionarioScalarWhereWithAggregatesInput | FuncionarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Funcionario"> | number
    usuarioId?: IntWithAggregatesFilter<"Funcionario"> | number
    nome?: StringWithAggregatesFilter<"Funcionario"> | string
    cargo?: StringWithAggregatesFilter<"Funcionario"> | string
    admin?: StringWithAggregatesFilter<"Funcionario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Funcionario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Funcionario"> | Date | string
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    id?: IntFilter<"Pedido"> | number
    clienteId?: IntFilter<"Pedido"> | number
    statusPedidoId?: IntFilter<"Pedido"> | number
    createdAt?: DateTimeFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeFilter<"Pedido"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    pagamento?: PagamentoListRelationFilter
    statusPedido?: XOR<StatusPedidoRelationFilter, StatusPedidoWhereInput>
    ProdutosDoPedido?: ProdutosDoPedidoListRelationFilter
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    pagamento?: PagamentoOrderByRelationAggregateInput
    statusPedido?: StatusPedidoOrderByWithRelationInput
    ProdutosDoPedido?: ProdutosDoPedidoOrderByRelationAggregateInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    clienteId?: IntFilter<"Pedido"> | number
    statusPedidoId?: IntFilter<"Pedido"> | number
    createdAt?: DateTimeFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeFilter<"Pedido"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    pagamento?: PagamentoListRelationFilter
    statusPedido?: XOR<StatusPedidoRelationFilter, StatusPedidoWhereInput>
    ProdutosDoPedido?: ProdutosDoPedidoListRelationFilter
  }, "id">

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pedido"> | number
    clienteId?: IntWithAggregatesFilter<"Pedido"> | number
    statusPedidoId?: IntWithAggregatesFilter<"Pedido"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
  }

  export type StatusPedidoWhereInput = {
    AND?: StatusPedidoWhereInput | StatusPedidoWhereInput[]
    OR?: StatusPedidoWhereInput[]
    NOT?: StatusPedidoWhereInput | StatusPedidoWhereInput[]
    id?: IntFilter<"StatusPedido"> | number
    enumerador?: StringFilter<"StatusPedido"> | string
    createdAt?: DateTimeFilter<"StatusPedido"> | Date | string
    updatedAt?: DateTimeFilter<"StatusPedido"> | Date | string
    pedido?: PedidoListRelationFilter
  }

  export type StatusPedidoOrderByWithRelationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedido?: PedidoOrderByRelationAggregateInput
  }

  export type StatusPedidoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enumerador?: string
    AND?: StatusPedidoWhereInput | StatusPedidoWhereInput[]
    OR?: StatusPedidoWhereInput[]
    NOT?: StatusPedidoWhereInput | StatusPedidoWhereInput[]
    createdAt?: DateTimeFilter<"StatusPedido"> | Date | string
    updatedAt?: DateTimeFilter<"StatusPedido"> | Date | string
    pedido?: PedidoListRelationFilter
  }, "id" | "enumerador">

  export type StatusPedidoOrderByWithAggregationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatusPedidoCountOrderByAggregateInput
    _avg?: StatusPedidoAvgOrderByAggregateInput
    _max?: StatusPedidoMaxOrderByAggregateInput
    _min?: StatusPedidoMinOrderByAggregateInput
    _sum?: StatusPedidoSumOrderByAggregateInput
  }

  export type StatusPedidoScalarWhereWithAggregatesInput = {
    AND?: StatusPedidoScalarWhereWithAggregatesInput | StatusPedidoScalarWhereWithAggregatesInput[]
    OR?: StatusPedidoScalarWhereWithAggregatesInput[]
    NOT?: StatusPedidoScalarWhereWithAggregatesInput | StatusPedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatusPedido"> | number
    enumerador?: StringWithAggregatesFilter<"StatusPedido"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StatusPedido"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatusPedido"> | Date | string
  }

  export type StatusPagamentoWhereInput = {
    AND?: StatusPagamentoWhereInput | StatusPagamentoWhereInput[]
    OR?: StatusPagamentoWhereInput[]
    NOT?: StatusPagamentoWhereInput | StatusPagamentoWhereInput[]
    id?: IntFilter<"StatusPagamento"> | number
    enumerador?: StringFilter<"StatusPagamento"> | string
    createdAt?: DateTimeFilter<"StatusPagamento"> | Date | string
    updatedAt?: DateTimeFilter<"StatusPagamento"> | Date | string
    pagamento?: PagamentoListRelationFilter
  }

  export type StatusPagamentoOrderByWithRelationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pagamento?: PagamentoOrderByRelationAggregateInput
  }

  export type StatusPagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enumerador?: string
    AND?: StatusPagamentoWhereInput | StatusPagamentoWhereInput[]
    OR?: StatusPagamentoWhereInput[]
    NOT?: StatusPagamentoWhereInput | StatusPagamentoWhereInput[]
    createdAt?: DateTimeFilter<"StatusPagamento"> | Date | string
    updatedAt?: DateTimeFilter<"StatusPagamento"> | Date | string
    pagamento?: PagamentoListRelationFilter
  }, "id" | "enumerador">

  export type StatusPagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatusPagamentoCountOrderByAggregateInput
    _avg?: StatusPagamentoAvgOrderByAggregateInput
    _max?: StatusPagamentoMaxOrderByAggregateInput
    _min?: StatusPagamentoMinOrderByAggregateInput
    _sum?: StatusPagamentoSumOrderByAggregateInput
  }

  export type StatusPagamentoScalarWhereWithAggregatesInput = {
    AND?: StatusPagamentoScalarWhereWithAggregatesInput | StatusPagamentoScalarWhereWithAggregatesInput[]
    OR?: StatusPagamentoScalarWhereWithAggregatesInput[]
    NOT?: StatusPagamentoScalarWhereWithAggregatesInput | StatusPagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatusPagamento"> | number
    enumerador?: StringWithAggregatesFilter<"StatusPagamento"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StatusPagamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatusPagamento"> | Date | string
  }

  export type CardapioWhereInput = {
    AND?: CardapioWhereInput | CardapioWhereInput[]
    OR?: CardapioWhereInput[]
    NOT?: CardapioWhereInput | CardapioWhereInput[]
    id?: IntFilter<"Cardapio"> | number
    descricao?: StringFilter<"Cardapio"> | string
    ativo?: BoolFilter<"Cardapio"> | boolean
    createdAt?: DateTimeFilter<"Cardapio"> | Date | string
    updatedAt?: DateTimeFilter<"Cardapio"> | Date | string
    produtosDoCardapio?: ProdutosDoCardapioListRelationFilter
  }

  export type CardapioOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produtosDoCardapio?: ProdutosDoCardapioOrderByRelationAggregateInput
  }

  export type CardapioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardapioWhereInput | CardapioWhereInput[]
    OR?: CardapioWhereInput[]
    NOT?: CardapioWhereInput | CardapioWhereInput[]
    descricao?: StringFilter<"Cardapio"> | string
    ativo?: BoolFilter<"Cardapio"> | boolean
    createdAt?: DateTimeFilter<"Cardapio"> | Date | string
    updatedAt?: DateTimeFilter<"Cardapio"> | Date | string
    produtosDoCardapio?: ProdutosDoCardapioListRelationFilter
  }, "id">

  export type CardapioOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CardapioCountOrderByAggregateInput
    _avg?: CardapioAvgOrderByAggregateInput
    _max?: CardapioMaxOrderByAggregateInput
    _min?: CardapioMinOrderByAggregateInput
    _sum?: CardapioSumOrderByAggregateInput
  }

  export type CardapioScalarWhereWithAggregatesInput = {
    AND?: CardapioScalarWhereWithAggregatesInput | CardapioScalarWhereWithAggregatesInput[]
    OR?: CardapioScalarWhereWithAggregatesInput[]
    NOT?: CardapioScalarWhereWithAggregatesInput | CardapioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cardapio"> | number
    descricao?: StringWithAggregatesFilter<"Cardapio"> | string
    ativo?: BoolWithAggregatesFilter<"Cardapio"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Cardapio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cardapio"> | Date | string
  }

  export type ProdutosDoPedidoWhereInput = {
    AND?: ProdutosDoPedidoWhereInput | ProdutosDoPedidoWhereInput[]
    OR?: ProdutosDoPedidoWhereInput[]
    NOT?: ProdutosDoPedidoWhereInput | ProdutosDoPedidoWhereInput[]
    id?: IntFilter<"ProdutosDoPedido"> | number
    produtoId?: IntFilter<"ProdutosDoPedido"> | number
    pedidoId?: IntFilter<"ProdutosDoPedido"> | number
    quantidade?: IntFilter<"ProdutosDoPedido"> | number
    valor?: DecimalFilter<"ProdutosDoPedido"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ProdutosDoPedido"> | Date | string
    updatedAt?: DateTimeFilter<"ProdutosDoPedido"> | Date | string
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }

  export type ProdutosDoPedidoOrderByWithRelationInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produto?: ProdutoOrderByWithRelationInput
    pedido?: PedidoOrderByWithRelationInput
  }

  export type ProdutosDoPedidoWhereUniqueInput = Prisma.AtLeast<{
    produtoId_pedidoId_id?: ProdutosDoPedidoProdutoIdPedidoIdIdCompoundUniqueInput
    AND?: ProdutosDoPedidoWhereInput | ProdutosDoPedidoWhereInput[]
    OR?: ProdutosDoPedidoWhereInput[]
    NOT?: ProdutosDoPedidoWhereInput | ProdutosDoPedidoWhereInput[]
    id?: IntFilter<"ProdutosDoPedido"> | number
    produtoId?: IntFilter<"ProdutosDoPedido"> | number
    pedidoId?: IntFilter<"ProdutosDoPedido"> | number
    quantidade?: IntFilter<"ProdutosDoPedido"> | number
    valor?: DecimalFilter<"ProdutosDoPedido"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ProdutosDoPedido"> | Date | string
    updatedAt?: DateTimeFilter<"ProdutosDoPedido"> | Date | string
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }, "produtoId_pedidoId_id">

  export type ProdutosDoPedidoOrderByWithAggregationInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProdutosDoPedidoCountOrderByAggregateInput
    _avg?: ProdutosDoPedidoAvgOrderByAggregateInput
    _max?: ProdutosDoPedidoMaxOrderByAggregateInput
    _min?: ProdutosDoPedidoMinOrderByAggregateInput
    _sum?: ProdutosDoPedidoSumOrderByAggregateInput
  }

  export type ProdutosDoPedidoScalarWhereWithAggregatesInput = {
    AND?: ProdutosDoPedidoScalarWhereWithAggregatesInput | ProdutosDoPedidoScalarWhereWithAggregatesInput[]
    OR?: ProdutosDoPedidoScalarWhereWithAggregatesInput[]
    NOT?: ProdutosDoPedidoScalarWhereWithAggregatesInput | ProdutosDoPedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProdutosDoPedido"> | number
    produtoId?: IntWithAggregatesFilter<"ProdutosDoPedido"> | number
    pedidoId?: IntWithAggregatesFilter<"ProdutosDoPedido"> | number
    quantidade?: IntWithAggregatesFilter<"ProdutosDoPedido"> | number
    valor?: DecimalWithAggregatesFilter<"ProdutosDoPedido"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ProdutosDoPedido"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProdutosDoPedido"> | Date | string
  }

  export type ProdutoWhereInput = {
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    id?: IntFilter<"Produto"> | number
    categoriaProdutoId?: IntFilter<"Produto"> | number
    descricao?: StringFilter<"Produto"> | string
    preco?: DecimalFilter<"Produto"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Produto"> | Date | string
    updatedAt?: DateTimeFilter<"Produto"> | Date | string
    produtosDoCardapio?: ProdutosDoCardapioListRelationFilter
    ProdutosDoPedido?: ProdutosDoPedidoListRelationFilter
    categoriaProduto?: XOR<CategoriaProdutoRelationFilter, CategoriaProdutoWhereInput>
  }

  export type ProdutoOrderByWithRelationInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    descricao?: SortOrder
    preco?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produtosDoCardapio?: ProdutosDoCardapioOrderByRelationAggregateInput
    ProdutosDoPedido?: ProdutosDoPedidoOrderByRelationAggregateInput
    categoriaProduto?: CategoriaProdutoOrderByWithRelationInput
  }

  export type ProdutoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    categoriaProdutoId?: IntFilter<"Produto"> | number
    descricao?: StringFilter<"Produto"> | string
    preco?: DecimalFilter<"Produto"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Produto"> | Date | string
    updatedAt?: DateTimeFilter<"Produto"> | Date | string
    produtosDoCardapio?: ProdutosDoCardapioListRelationFilter
    ProdutosDoPedido?: ProdutosDoPedidoListRelationFilter
    categoriaProduto?: XOR<CategoriaProdutoRelationFilter, CategoriaProdutoWhereInput>
  }, "id">

  export type ProdutoOrderByWithAggregationInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    descricao?: SortOrder
    preco?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProdutoCountOrderByAggregateInput
    _avg?: ProdutoAvgOrderByAggregateInput
    _max?: ProdutoMaxOrderByAggregateInput
    _min?: ProdutoMinOrderByAggregateInput
    _sum?: ProdutoSumOrderByAggregateInput
  }

  export type ProdutoScalarWhereWithAggregatesInput = {
    AND?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    OR?: ProdutoScalarWhereWithAggregatesInput[]
    NOT?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Produto"> | number
    categoriaProdutoId?: IntWithAggregatesFilter<"Produto"> | number
    descricao?: StringWithAggregatesFilter<"Produto"> | string
    preco?: DecimalWithAggregatesFilter<"Produto"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Produto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Produto"> | Date | string
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    statusPagamentoId?: IntFilter<"Pagamento"> | number
    pedidoId?: IntFilter<"Pagamento"> | number
    tipo?: StringFilter<"Pagamento"> | string
    data?: DateTimeFilter<"Pagamento"> | Date | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    statusPagamento?: XOR<StatusPagamentoRelationFilter, StatusPagamentoWhereInput>
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    tipo?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    statusPagamento?: StatusPagamentoOrderByWithRelationInput
    pedido?: PedidoOrderByWithRelationInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    statusPagamentoId?: IntFilter<"Pagamento"> | number
    pedidoId?: IntFilter<"Pagamento"> | number
    tipo?: StringFilter<"Pagamento"> | string
    data?: DateTimeFilter<"Pagamento"> | Date | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    statusPagamento?: XOR<StatusPagamentoRelationFilter, StatusPagamentoWhereInput>
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }, "id">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    tipo?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pagamento"> | number
    statusPagamentoId?: IntWithAggregatesFilter<"Pagamento"> | number
    pedidoId?: IntWithAggregatesFilter<"Pagamento"> | number
    tipo?: StringWithAggregatesFilter<"Pagamento"> | string
    data?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    valor?: DecimalWithAggregatesFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
  }

  export type CategoriaProdutoWhereInput = {
    AND?: CategoriaProdutoWhereInput | CategoriaProdutoWhereInput[]
    OR?: CategoriaProdutoWhereInput[]
    NOT?: CategoriaProdutoWhereInput | CategoriaProdutoWhereInput[]
    id?: IntFilter<"CategoriaProduto"> | number
    enumerador?: StringFilter<"CategoriaProduto"> | string
    createdAt?: DateTimeFilter<"CategoriaProduto"> | Date | string
    updatedAt?: DateTimeFilter<"CategoriaProduto"> | Date | string
    produto?: ProdutoListRelationFilter
  }

  export type CategoriaProdutoOrderByWithRelationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produto?: ProdutoOrderByRelationAggregateInput
  }

  export type CategoriaProdutoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enumerador?: string
    AND?: CategoriaProdutoWhereInput | CategoriaProdutoWhereInput[]
    OR?: CategoriaProdutoWhereInput[]
    NOT?: CategoriaProdutoWhereInput | CategoriaProdutoWhereInput[]
    createdAt?: DateTimeFilter<"CategoriaProduto"> | Date | string
    updatedAt?: DateTimeFilter<"CategoriaProduto"> | Date | string
    produto?: ProdutoListRelationFilter
  }, "id" | "enumerador">

  export type CategoriaProdutoOrderByWithAggregationInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoriaProdutoCountOrderByAggregateInput
    _avg?: CategoriaProdutoAvgOrderByAggregateInput
    _max?: CategoriaProdutoMaxOrderByAggregateInput
    _min?: CategoriaProdutoMinOrderByAggregateInput
    _sum?: CategoriaProdutoSumOrderByAggregateInput
  }

  export type CategoriaProdutoScalarWhereWithAggregatesInput = {
    AND?: CategoriaProdutoScalarWhereWithAggregatesInput | CategoriaProdutoScalarWhereWithAggregatesInput[]
    OR?: CategoriaProdutoScalarWhereWithAggregatesInput[]
    NOT?: CategoriaProdutoScalarWhereWithAggregatesInput | CategoriaProdutoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CategoriaProduto"> | number
    enumerador?: StringWithAggregatesFilter<"CategoriaProduto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CategoriaProduto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoriaProduto"> | Date | string
  }

  export type ProdutosDoCardapioWhereInput = {
    AND?: ProdutosDoCardapioWhereInput | ProdutosDoCardapioWhereInput[]
    OR?: ProdutosDoCardapioWhereInput[]
    NOT?: ProdutosDoCardapioWhereInput | ProdutosDoCardapioWhereInput[]
    id?: IntFilter<"ProdutosDoCardapio"> | number
    produtoId?: IntFilter<"ProdutosDoCardapio"> | number
    cardapioId?: IntFilter<"ProdutosDoCardapio"> | number
    createdAt?: DateTimeFilter<"ProdutosDoCardapio"> | Date | string
    updatedAt?: DateTimeFilter<"ProdutosDoCardapio"> | Date | string
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    cardapio?: XOR<CardapioRelationFilter, CardapioWhereInput>
  }

  export type ProdutosDoCardapioOrderByWithRelationInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produto?: ProdutoOrderByWithRelationInput
    cardapio?: CardapioOrderByWithRelationInput
  }

  export type ProdutosDoCardapioWhereUniqueInput = Prisma.AtLeast<{
    produtoId_cardapioId_id?: ProdutosDoCardapioProdutoIdCardapioIdIdCompoundUniqueInput
    AND?: ProdutosDoCardapioWhereInput | ProdutosDoCardapioWhereInput[]
    OR?: ProdutosDoCardapioWhereInput[]
    NOT?: ProdutosDoCardapioWhereInput | ProdutosDoCardapioWhereInput[]
    id?: IntFilter<"ProdutosDoCardapio"> | number
    produtoId?: IntFilter<"ProdutosDoCardapio"> | number
    cardapioId?: IntFilter<"ProdutosDoCardapio"> | number
    createdAt?: DateTimeFilter<"ProdutosDoCardapio"> | Date | string
    updatedAt?: DateTimeFilter<"ProdutosDoCardapio"> | Date | string
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    cardapio?: XOR<CardapioRelationFilter, CardapioWhereInput>
  }, "produtoId_cardapioId_id">

  export type ProdutosDoCardapioOrderByWithAggregationInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProdutosDoCardapioCountOrderByAggregateInput
    _avg?: ProdutosDoCardapioAvgOrderByAggregateInput
    _max?: ProdutosDoCardapioMaxOrderByAggregateInput
    _min?: ProdutosDoCardapioMinOrderByAggregateInput
    _sum?: ProdutosDoCardapioSumOrderByAggregateInput
  }

  export type ProdutosDoCardapioScalarWhereWithAggregatesInput = {
    AND?: ProdutosDoCardapioScalarWhereWithAggregatesInput | ProdutosDoCardapioScalarWhereWithAggregatesInput[]
    OR?: ProdutosDoCardapioScalarWhereWithAggregatesInput[]
    NOT?: ProdutosDoCardapioScalarWhereWithAggregatesInput | ProdutosDoCardapioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProdutosDoCardapio"> | number
    produtoId?: IntWithAggregatesFilter<"ProdutosDoCardapio"> | number
    cardapioId?: IntWithAggregatesFilter<"ProdutosDoCardapio"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProdutosDoCardapio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProdutosDoCardapio"> | Date | string
  }

  export type ClienteCreateInput = {
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    pedido?: PedidoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: number
    usuarioId: number
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    pedido?: PedidoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: number
    usuarioId: number
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAcessoCreateInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoAcessoUncheckedCreateInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoAcessoUpdateInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAcessoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAcessoCreateManyInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoAcessoUpdateManyMutationInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAcessoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateInput = {
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funcionario?: FuncionarioCreateNestedOneWithoutUsuarioInput
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funcionario?: FuncionarioUncheckedCreateNestedOneWithoutUsuarioInput
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funcionario?: FuncionarioUpdateOneWithoutUsuarioNestedInput
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funcionario?: FuncionarioUncheckedUpdateOneWithoutUsuarioNestedInput
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FuncionarioCreateInput = {
    nome: string
    cargo: string
    admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutFuncionarioInput
  }

  export type FuncionarioUncheckedCreateInput = {
    id?: number
    usuarioId: number
    nome: string
    cargo: string
    admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FuncionarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutFuncionarioNestedInput
  }

  export type FuncionarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FuncionarioCreateManyInput = {
    id?: number
    usuarioId: number
    nome: string
    cargo: string
    admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FuncionarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FuncionarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidoInput
    pagamento?: PagamentoCreateNestedManyWithoutPedidoInput
    statusPedido: StatusPedidoCreateNestedOneWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    clienteId: number
    statusPedidoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidoNestedInput
    pagamento?: PagamentoUpdateManyWithoutPedidoNestedInput
    statusPedido?: StatusPedidoUpdateOneRequiredWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    statusPedidoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUncheckedUpdateManyWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id?: number
    clienteId: number
    statusPedidoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    statusPedidoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPedidoCreateInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoCreateNestedManyWithoutStatusPedidoInput
  }

  export type StatusPedidoUncheckedCreateInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoUncheckedCreateNestedManyWithoutStatusPedidoInput
  }

  export type StatusPedidoUpdateInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateManyWithoutStatusPedidoNestedInput
  }

  export type StatusPedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUncheckedUpdateManyWithoutStatusPedidoNestedInput
  }

  export type StatusPedidoCreateManyInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPedidoUpdateManyMutationInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPagamentoCreateInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoCreateNestedManyWithoutStatusPagamentoInput
  }

  export type StatusPagamentoUncheckedCreateInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutStatusPagamentoInput
  }

  export type StatusPagamentoUpdateInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUpdateManyWithoutStatusPagamentoNestedInput
  }

  export type StatusPagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUncheckedUpdateManyWithoutStatusPagamentoNestedInput
  }

  export type StatusPagamentoCreateManyInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPagamentoUpdateManyMutationInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardapioCreateInput = {
    descricao: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioCreateNestedManyWithoutCardapioInput
  }

  export type CardapioUncheckedCreateInput = {
    id?: number
    descricao: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedCreateNestedManyWithoutCardapioInput
  }

  export type CardapioUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUpdateManyWithoutCardapioNestedInput
  }

  export type CardapioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedUpdateManyWithoutCardapioNestedInput
  }

  export type CardapioCreateManyInput = {
    id?: number
    descricao: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardapioUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardapioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoCreateInput = {
    id?: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produto: ProdutoCreateNestedOneWithoutProdutosDoPedidoInput
    pedido: PedidoCreateNestedOneWithoutProdutosDoPedidoInput
  }

  export type ProdutosDoPedidoUncheckedCreateInput = {
    id?: number
    produtoId: number
    pedidoId: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoPedidoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produto?: ProdutoUpdateOneRequiredWithoutProdutosDoPedidoNestedInput
    pedido?: PedidoUpdateOneRequiredWithoutProdutosDoPedidoNestedInput
  }

  export type ProdutosDoPedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoCreateManyInput = {
    id?: number
    produtoId: number
    pedidoId: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoPedidoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutoCreateInput = {
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioCreateNestedManyWithoutProdutoInput
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutProdutoInput
    categoriaProduto: CategoriaProdutoCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateInput = {
    id?: number
    categoriaProdutoId: number
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedCreateNestedManyWithoutProdutoInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUpdateManyWithoutProdutoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutProdutoNestedInput
    categoriaProduto?: CategoriaProdutoUpdateOneRequiredWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoriaProdutoId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedUpdateManyWithoutProdutoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoCreateManyInput = {
    id?: number
    categoriaProdutoId: number
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoriaProdutoId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateInput = {
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    statusPagamento: StatusPagamentoCreateNestedOneWithoutPagamentoInput
    pedido: PedidoCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: number
    statusPagamentoId: number
    pedidoId: number
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusPagamento?: StatusPagamentoUpdateOneRequiredWithoutPagamentoNestedInput
    pedido?: PedidoUpdateOneRequiredWithoutPagamentoNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusPagamentoId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyInput = {
    id?: number
    statusPagamentoId: number
    pedidoId: number
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusPagamentoId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaProdutoCreateInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
    produto?: ProdutoCreateNestedManyWithoutCategoriaProdutoInput
  }

  export type CategoriaProdutoUncheckedCreateInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
    produto?: ProdutoUncheckedCreateNestedManyWithoutCategoriaProdutoInput
  }

  export type CategoriaProdutoUpdateInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produto?: ProdutoUpdateManyWithoutCategoriaProdutoNestedInput
  }

  export type CategoriaProdutoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produto?: ProdutoUncheckedUpdateManyWithoutCategoriaProdutoNestedInput
  }

  export type CategoriaProdutoCreateManyInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaProdutoUpdateManyMutationInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaProdutoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produto: ProdutoCreateNestedOneWithoutProdutosDoCardapioInput
    cardapio: CardapioCreateNestedOneWithoutProdutosDoCardapioInput
  }

  export type ProdutosDoCardapioUncheckedCreateInput = {
    id?: number
    produtoId: number
    cardapioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoCardapioUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produto?: ProdutoUpdateOneRequiredWithoutProdutosDoCardapioNestedInput
    cardapio?: CardapioUpdateOneRequiredWithoutProdutosDoCardapioNestedInput
  }

  export type ProdutosDoCardapioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    cardapioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioCreateManyInput = {
    id?: number
    produtoId: number
    cardapioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoCardapioUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    cardapioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TipoAcessoCountOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoAcessoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoAcessoMaxOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoAcessoMinOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoAcessoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FuncionarioNullableRelationFilter = {
    is?: FuncionarioWhereInput | null
    isNot?: FuncionarioWhereInput | null
  }

  export type ClienteNullableRelationFilter = {
    is?: ClienteWhereInput | null
    isNot?: ClienteWhereInput | null
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    tipoAcesso?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoAcesso?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    tipoAcesso?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FuncionarioCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    cargo?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FuncionarioAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type FuncionarioMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    cargo?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FuncionarioMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    cargo?: SortOrder
    admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FuncionarioSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type PagamentoListRelationFilter = {
    every?: PagamentoWhereInput
    some?: PagamentoWhereInput
    none?: PagamentoWhereInput
  }

  export type StatusPedidoRelationFilter = {
    is?: StatusPedidoWhereInput
    isNot?: StatusPedidoWhereInput
  }

  export type ProdutosDoPedidoListRelationFilter = {
    every?: ProdutosDoPedidoWhereInput
    some?: ProdutosDoPedidoWhereInput
    none?: ProdutosDoPedidoWhereInput
  }

  export type PagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProdutosDoPedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    statusPedidoId?: SortOrder
  }

  export type StatusPedidoCountOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPedidoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusPedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPedidoMinOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPedidoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusPagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusPagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPagamentoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProdutosDoCardapioListRelationFilter = {
    every?: ProdutosDoCardapioWhereInput
    some?: ProdutosDoCardapioWhereInput
    none?: ProdutosDoCardapioWhereInput
  }

  export type ProdutosDoCardapioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardapioCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardapioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CardapioMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardapioMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardapioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ProdutoRelationFilter = {
    is?: ProdutoWhereInput
    isNot?: ProdutoWhereInput
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type ProdutosDoPedidoProdutoIdPedidoIdIdCompoundUniqueInput = {
    produtoId: number
    pedidoId: number
    id: number
  }

  export type ProdutosDoPedidoCountOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutosDoPedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
  }

  export type ProdutosDoPedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutosDoPedidoMinOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutosDoPedidoSumOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    pedidoId?: SortOrder
    quantidade?: SortOrder
    valor?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CategoriaProdutoRelationFilter = {
    is?: CategoriaProdutoWhereInput
    isNot?: CategoriaProdutoWhereInput
  }

  export type ProdutoCountOrderByAggregateInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    descricao?: SortOrder
    preco?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutoAvgOrderByAggregateInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    preco?: SortOrder
  }

  export type ProdutoMaxOrderByAggregateInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    descricao?: SortOrder
    preco?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutoMinOrderByAggregateInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    descricao?: SortOrder
    preco?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutoSumOrderByAggregateInput = {
    id?: SortOrder
    categoriaProdutoId?: SortOrder
    preco?: SortOrder
  }

  export type StatusPagamentoRelationFilter = {
    is?: StatusPagamentoWhereInput
    isNot?: StatusPagamentoWhereInput
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    tipo?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    valor?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    tipo?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    tipo?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    id?: SortOrder
    statusPagamentoId?: SortOrder
    pedidoId?: SortOrder
    valor?: SortOrder
  }

  export type ProdutoListRelationFilter = {
    every?: ProdutoWhereInput
    some?: ProdutoWhereInput
    none?: ProdutoWhereInput
  }

  export type ProdutoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaProdutoCountOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriaProdutoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaProdutoMaxOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriaProdutoMinOrderByAggregateInput = {
    id?: SortOrder
    enumerador?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriaProdutoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CardapioRelationFilter = {
    is?: CardapioWhereInput
    isNot?: CardapioWhereInput
  }

  export type ProdutosDoCardapioProdutoIdCardapioIdIdCompoundUniqueInput = {
    produtoId: number
    cardapioId: number
    id: number
  }

  export type ProdutosDoCardapioCountOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutosDoCardapioAvgOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
  }

  export type ProdutosDoCardapioMaxOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutosDoCardapioMinOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProdutosDoCardapioSumOrderByAggregateInput = {
    id?: SortOrder
    produtoId?: SortOrder
    cardapioId?: SortOrder
  }

  export type UsuarioCreateNestedOneWithoutClienteInput = {
    create?: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutClienteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoCreateNestedManyWithoutClienteInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsuarioUpdateOneRequiredWithoutClienteNestedInput = {
    create?: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutClienteInput
    upsert?: UsuarioUpsertWithoutClienteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutClienteInput, UsuarioUpdateWithoutClienteInput>, UsuarioUncheckedUpdateWithoutClienteInput>
  }

  export type PedidoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutClienteInput | PedidoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutClienteInput | PedidoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutClienteInput | PedidoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PedidoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutClienteInput | PedidoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutClienteInput | PedidoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutClienteInput | PedidoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type FuncionarioCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<FuncionarioCreateWithoutUsuarioInput, FuncionarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FuncionarioCreateOrConnectWithoutUsuarioInput
    connect?: FuncionarioWhereUniqueInput
  }

  export type ClienteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    connect?: ClienteWhereUniqueInput
  }

  export type FuncionarioUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<FuncionarioCreateWithoutUsuarioInput, FuncionarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FuncionarioCreateOrConnectWithoutUsuarioInput
    connect?: FuncionarioWhereUniqueInput
  }

  export type ClienteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    connect?: ClienteWhereUniqueInput
  }

  export type FuncionarioUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<FuncionarioCreateWithoutUsuarioInput, FuncionarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FuncionarioCreateOrConnectWithoutUsuarioInput
    upsert?: FuncionarioUpsertWithoutUsuarioInput
    disconnect?: FuncionarioWhereInput | boolean
    delete?: FuncionarioWhereInput | boolean
    connect?: FuncionarioWhereUniqueInput
    update?: XOR<XOR<FuncionarioUpdateToOneWithWhereWithoutUsuarioInput, FuncionarioUpdateWithoutUsuarioInput>, FuncionarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ClienteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    upsert?: ClienteUpsertWithoutUsuarioInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutUsuarioInput, ClienteUpdateWithoutUsuarioInput>, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type FuncionarioUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<FuncionarioCreateWithoutUsuarioInput, FuncionarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FuncionarioCreateOrConnectWithoutUsuarioInput
    upsert?: FuncionarioUpsertWithoutUsuarioInput
    disconnect?: FuncionarioWhereInput | boolean
    delete?: FuncionarioWhereInput | boolean
    connect?: FuncionarioWhereUniqueInput
    update?: XOR<XOR<FuncionarioUpdateToOneWithWhereWithoutUsuarioInput, FuncionarioUpdateWithoutUsuarioInput>, FuncionarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ClienteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    upsert?: ClienteUpsertWithoutUsuarioInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutUsuarioInput, ClienteUpdateWithoutUsuarioInput>, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioCreateNestedOneWithoutFuncionarioInput = {
    create?: XOR<UsuarioCreateWithoutFuncionarioInput, UsuarioUncheckedCreateWithoutFuncionarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFuncionarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutFuncionarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutFuncionarioInput, UsuarioUncheckedCreateWithoutFuncionarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFuncionarioInput
    upsert?: UsuarioUpsertWithoutFuncionarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutFuncionarioInput, UsuarioUpdateWithoutFuncionarioInput>, UsuarioUncheckedUpdateWithoutFuncionarioInput>
  }

  export type ClienteCreateNestedOneWithoutPedidoInput = {
    create?: XOR<ClienteCreateWithoutPedidoInput, ClienteUncheckedCreateWithoutPedidoInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPedidoInput
    connect?: ClienteWhereUniqueInput
  }

  export type PagamentoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PagamentoCreateWithoutPedidoInput, PagamentoUncheckedCreateWithoutPedidoInput> | PagamentoCreateWithoutPedidoInput[] | PagamentoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutPedidoInput | PagamentoCreateOrConnectWithoutPedidoInput[]
    createMany?: PagamentoCreateManyPedidoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type StatusPedidoCreateNestedOneWithoutPedidoInput = {
    create?: XOR<StatusPedidoCreateWithoutPedidoInput, StatusPedidoUncheckedCreateWithoutPedidoInput>
    connectOrCreate?: StatusPedidoCreateOrConnectWithoutPedidoInput
    connect?: StatusPedidoWhereUniqueInput
  }

  export type ProdutosDoPedidoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutPedidoInput, ProdutosDoPedidoUncheckedCreateWithoutPedidoInput> | ProdutosDoPedidoCreateWithoutPedidoInput[] | ProdutosDoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutPedidoInput | ProdutosDoPedidoCreateOrConnectWithoutPedidoInput[]
    createMany?: ProdutosDoPedidoCreateManyPedidoInputEnvelope
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PagamentoCreateWithoutPedidoInput, PagamentoUncheckedCreateWithoutPedidoInput> | PagamentoCreateWithoutPedidoInput[] | PagamentoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutPedidoInput | PagamentoCreateOrConnectWithoutPedidoInput[]
    createMany?: PagamentoCreateManyPedidoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type ProdutosDoPedidoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutPedidoInput, ProdutosDoPedidoUncheckedCreateWithoutPedidoInput> | ProdutosDoPedidoCreateWithoutPedidoInput[] | ProdutosDoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutPedidoInput | ProdutosDoPedidoCreateOrConnectWithoutPedidoInput[]
    createMany?: ProdutosDoPedidoCreateManyPedidoInputEnvelope
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
  }

  export type ClienteUpdateOneRequiredWithoutPedidoNestedInput = {
    create?: XOR<ClienteCreateWithoutPedidoInput, ClienteUncheckedCreateWithoutPedidoInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPedidoInput
    upsert?: ClienteUpsertWithoutPedidoInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutPedidoInput, ClienteUpdateWithoutPedidoInput>, ClienteUncheckedUpdateWithoutPedidoInput>
  }

  export type PagamentoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PagamentoCreateWithoutPedidoInput, PagamentoUncheckedCreateWithoutPedidoInput> | PagamentoCreateWithoutPedidoInput[] | PagamentoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutPedidoInput | PagamentoCreateOrConnectWithoutPedidoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutPedidoInput | PagamentoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PagamentoCreateManyPedidoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutPedidoInput | PagamentoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutPedidoInput | PagamentoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type StatusPedidoUpdateOneRequiredWithoutPedidoNestedInput = {
    create?: XOR<StatusPedidoCreateWithoutPedidoInput, StatusPedidoUncheckedCreateWithoutPedidoInput>
    connectOrCreate?: StatusPedidoCreateOrConnectWithoutPedidoInput
    upsert?: StatusPedidoUpsertWithoutPedidoInput
    connect?: StatusPedidoWhereUniqueInput
    update?: XOR<XOR<StatusPedidoUpdateToOneWithWhereWithoutPedidoInput, StatusPedidoUpdateWithoutPedidoInput>, StatusPedidoUncheckedUpdateWithoutPedidoInput>
  }

  export type ProdutosDoPedidoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutPedidoInput, ProdutosDoPedidoUncheckedCreateWithoutPedidoInput> | ProdutosDoPedidoCreateWithoutPedidoInput[] | ProdutosDoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutPedidoInput | ProdutosDoPedidoCreateOrConnectWithoutPedidoInput[]
    upsert?: ProdutosDoPedidoUpsertWithWhereUniqueWithoutPedidoInput | ProdutosDoPedidoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: ProdutosDoPedidoCreateManyPedidoInputEnvelope
    set?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    disconnect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    delete?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    update?: ProdutosDoPedidoUpdateWithWhereUniqueWithoutPedidoInput | ProdutosDoPedidoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: ProdutosDoPedidoUpdateManyWithWhereWithoutPedidoInput | ProdutosDoPedidoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: ProdutosDoPedidoScalarWhereInput | ProdutosDoPedidoScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PagamentoCreateWithoutPedidoInput, PagamentoUncheckedCreateWithoutPedidoInput> | PagamentoCreateWithoutPedidoInput[] | PagamentoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutPedidoInput | PagamentoCreateOrConnectWithoutPedidoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutPedidoInput | PagamentoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PagamentoCreateManyPedidoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutPedidoInput | PagamentoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutPedidoInput | PagamentoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutPedidoInput, ProdutosDoPedidoUncheckedCreateWithoutPedidoInput> | ProdutosDoPedidoCreateWithoutPedidoInput[] | ProdutosDoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutPedidoInput | ProdutosDoPedidoCreateOrConnectWithoutPedidoInput[]
    upsert?: ProdutosDoPedidoUpsertWithWhereUniqueWithoutPedidoInput | ProdutosDoPedidoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: ProdutosDoPedidoCreateManyPedidoInputEnvelope
    set?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    disconnect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    delete?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    update?: ProdutosDoPedidoUpdateWithWhereUniqueWithoutPedidoInput | ProdutosDoPedidoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: ProdutosDoPedidoUpdateManyWithWhereWithoutPedidoInput | ProdutosDoPedidoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: ProdutosDoPedidoScalarWhereInput | ProdutosDoPedidoScalarWhereInput[]
  }

  export type PedidoCreateNestedManyWithoutStatusPedidoInput = {
    create?: XOR<PedidoCreateWithoutStatusPedidoInput, PedidoUncheckedCreateWithoutStatusPedidoInput> | PedidoCreateWithoutStatusPedidoInput[] | PedidoUncheckedCreateWithoutStatusPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutStatusPedidoInput | PedidoCreateOrConnectWithoutStatusPedidoInput[]
    createMany?: PedidoCreateManyStatusPedidoInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutStatusPedidoInput = {
    create?: XOR<PedidoCreateWithoutStatusPedidoInput, PedidoUncheckedCreateWithoutStatusPedidoInput> | PedidoCreateWithoutStatusPedidoInput[] | PedidoUncheckedCreateWithoutStatusPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutStatusPedidoInput | PedidoCreateOrConnectWithoutStatusPedidoInput[]
    createMany?: PedidoCreateManyStatusPedidoInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type PedidoUpdateManyWithoutStatusPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutStatusPedidoInput, PedidoUncheckedCreateWithoutStatusPedidoInput> | PedidoCreateWithoutStatusPedidoInput[] | PedidoUncheckedCreateWithoutStatusPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutStatusPedidoInput | PedidoCreateOrConnectWithoutStatusPedidoInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutStatusPedidoInput | PedidoUpsertWithWhereUniqueWithoutStatusPedidoInput[]
    createMany?: PedidoCreateManyStatusPedidoInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutStatusPedidoInput | PedidoUpdateWithWhereUniqueWithoutStatusPedidoInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutStatusPedidoInput | PedidoUpdateManyWithWhereWithoutStatusPedidoInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutStatusPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutStatusPedidoInput, PedidoUncheckedCreateWithoutStatusPedidoInput> | PedidoCreateWithoutStatusPedidoInput[] | PedidoUncheckedCreateWithoutStatusPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutStatusPedidoInput | PedidoCreateOrConnectWithoutStatusPedidoInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutStatusPedidoInput | PedidoUpsertWithWhereUniqueWithoutStatusPedidoInput[]
    createMany?: PedidoCreateManyStatusPedidoInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutStatusPedidoInput | PedidoUpdateWithWhereUniqueWithoutStatusPedidoInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutStatusPedidoInput | PedidoUpdateManyWithWhereWithoutStatusPedidoInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type PagamentoCreateNestedManyWithoutStatusPagamentoInput = {
    create?: XOR<PagamentoCreateWithoutStatusPagamentoInput, PagamentoUncheckedCreateWithoutStatusPagamentoInput> | PagamentoCreateWithoutStatusPagamentoInput[] | PagamentoUncheckedCreateWithoutStatusPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutStatusPagamentoInput | PagamentoCreateOrConnectWithoutStatusPagamentoInput[]
    createMany?: PagamentoCreateManyStatusPagamentoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutStatusPagamentoInput = {
    create?: XOR<PagamentoCreateWithoutStatusPagamentoInput, PagamentoUncheckedCreateWithoutStatusPagamentoInput> | PagamentoCreateWithoutStatusPagamentoInput[] | PagamentoUncheckedCreateWithoutStatusPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutStatusPagamentoInput | PagamentoCreateOrConnectWithoutStatusPagamentoInput[]
    createMany?: PagamentoCreateManyStatusPagamentoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type PagamentoUpdateManyWithoutStatusPagamentoNestedInput = {
    create?: XOR<PagamentoCreateWithoutStatusPagamentoInput, PagamentoUncheckedCreateWithoutStatusPagamentoInput> | PagamentoCreateWithoutStatusPagamentoInput[] | PagamentoUncheckedCreateWithoutStatusPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutStatusPagamentoInput | PagamentoCreateOrConnectWithoutStatusPagamentoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutStatusPagamentoInput | PagamentoUpsertWithWhereUniqueWithoutStatusPagamentoInput[]
    createMany?: PagamentoCreateManyStatusPagamentoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutStatusPagamentoInput | PagamentoUpdateWithWhereUniqueWithoutStatusPagamentoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutStatusPagamentoInput | PagamentoUpdateManyWithWhereWithoutStatusPagamentoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutStatusPagamentoNestedInput = {
    create?: XOR<PagamentoCreateWithoutStatusPagamentoInput, PagamentoUncheckedCreateWithoutStatusPagamentoInput> | PagamentoCreateWithoutStatusPagamentoInput[] | PagamentoUncheckedCreateWithoutStatusPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutStatusPagamentoInput | PagamentoCreateOrConnectWithoutStatusPagamentoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutStatusPagamentoInput | PagamentoUpsertWithWhereUniqueWithoutStatusPagamentoInput[]
    createMany?: PagamentoCreateManyStatusPagamentoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutStatusPagamentoInput | PagamentoUpdateWithWhereUniqueWithoutStatusPagamentoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutStatusPagamentoInput | PagamentoUpdateManyWithWhereWithoutStatusPagamentoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type ProdutosDoCardapioCreateNestedManyWithoutCardapioInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutCardapioInput, ProdutosDoCardapioUncheckedCreateWithoutCardapioInput> | ProdutosDoCardapioCreateWithoutCardapioInput[] | ProdutosDoCardapioUncheckedCreateWithoutCardapioInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutCardapioInput | ProdutosDoCardapioCreateOrConnectWithoutCardapioInput[]
    createMany?: ProdutosDoCardapioCreateManyCardapioInputEnvelope
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
  }

  export type ProdutosDoCardapioUncheckedCreateNestedManyWithoutCardapioInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutCardapioInput, ProdutosDoCardapioUncheckedCreateWithoutCardapioInput> | ProdutosDoCardapioCreateWithoutCardapioInput[] | ProdutosDoCardapioUncheckedCreateWithoutCardapioInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutCardapioInput | ProdutosDoCardapioCreateOrConnectWithoutCardapioInput[]
    createMany?: ProdutosDoCardapioCreateManyCardapioInputEnvelope
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProdutosDoCardapioUpdateManyWithoutCardapioNestedInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutCardapioInput, ProdutosDoCardapioUncheckedCreateWithoutCardapioInput> | ProdutosDoCardapioCreateWithoutCardapioInput[] | ProdutosDoCardapioUncheckedCreateWithoutCardapioInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutCardapioInput | ProdutosDoCardapioCreateOrConnectWithoutCardapioInput[]
    upsert?: ProdutosDoCardapioUpsertWithWhereUniqueWithoutCardapioInput | ProdutosDoCardapioUpsertWithWhereUniqueWithoutCardapioInput[]
    createMany?: ProdutosDoCardapioCreateManyCardapioInputEnvelope
    set?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    disconnect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    delete?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    update?: ProdutosDoCardapioUpdateWithWhereUniqueWithoutCardapioInput | ProdutosDoCardapioUpdateWithWhereUniqueWithoutCardapioInput[]
    updateMany?: ProdutosDoCardapioUpdateManyWithWhereWithoutCardapioInput | ProdutosDoCardapioUpdateManyWithWhereWithoutCardapioInput[]
    deleteMany?: ProdutosDoCardapioScalarWhereInput | ProdutosDoCardapioScalarWhereInput[]
  }

  export type ProdutosDoCardapioUncheckedUpdateManyWithoutCardapioNestedInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutCardapioInput, ProdutosDoCardapioUncheckedCreateWithoutCardapioInput> | ProdutosDoCardapioCreateWithoutCardapioInput[] | ProdutosDoCardapioUncheckedCreateWithoutCardapioInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutCardapioInput | ProdutosDoCardapioCreateOrConnectWithoutCardapioInput[]
    upsert?: ProdutosDoCardapioUpsertWithWhereUniqueWithoutCardapioInput | ProdutosDoCardapioUpsertWithWhereUniqueWithoutCardapioInput[]
    createMany?: ProdutosDoCardapioCreateManyCardapioInputEnvelope
    set?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    disconnect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    delete?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    update?: ProdutosDoCardapioUpdateWithWhereUniqueWithoutCardapioInput | ProdutosDoCardapioUpdateWithWhereUniqueWithoutCardapioInput[]
    updateMany?: ProdutosDoCardapioUpdateManyWithWhereWithoutCardapioInput | ProdutosDoCardapioUpdateManyWithWhereWithoutCardapioInput[]
    deleteMany?: ProdutosDoCardapioScalarWhereInput | ProdutosDoCardapioScalarWhereInput[]
  }

  export type ProdutoCreateNestedOneWithoutProdutosDoPedidoInput = {
    create?: XOR<ProdutoCreateWithoutProdutosDoPedidoInput, ProdutoUncheckedCreateWithoutProdutosDoPedidoInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutProdutosDoPedidoInput
    connect?: ProdutoWhereUniqueInput
  }

  export type PedidoCreateNestedOneWithoutProdutosDoPedidoInput = {
    create?: XOR<PedidoCreateWithoutProdutosDoPedidoInput, PedidoUncheckedCreateWithoutProdutosDoPedidoInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutProdutosDoPedidoInput
    connect?: PedidoWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProdutoUpdateOneRequiredWithoutProdutosDoPedidoNestedInput = {
    create?: XOR<ProdutoCreateWithoutProdutosDoPedidoInput, ProdutoUncheckedCreateWithoutProdutosDoPedidoInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutProdutosDoPedidoInput
    upsert?: ProdutoUpsertWithoutProdutosDoPedidoInput
    connect?: ProdutoWhereUniqueInput
    update?: XOR<XOR<ProdutoUpdateToOneWithWhereWithoutProdutosDoPedidoInput, ProdutoUpdateWithoutProdutosDoPedidoInput>, ProdutoUncheckedUpdateWithoutProdutosDoPedidoInput>
  }

  export type PedidoUpdateOneRequiredWithoutProdutosDoPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutProdutosDoPedidoInput, PedidoUncheckedCreateWithoutProdutosDoPedidoInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutProdutosDoPedidoInput
    upsert?: PedidoUpsertWithoutProdutosDoPedidoInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutProdutosDoPedidoInput, PedidoUpdateWithoutProdutosDoPedidoInput>, PedidoUncheckedUpdateWithoutProdutosDoPedidoInput>
  }

  export type ProdutosDoCardapioCreateNestedManyWithoutProdutoInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutProdutoInput, ProdutosDoCardapioUncheckedCreateWithoutProdutoInput> | ProdutosDoCardapioCreateWithoutProdutoInput[] | ProdutosDoCardapioUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutProdutoInput | ProdutosDoCardapioCreateOrConnectWithoutProdutoInput[]
    createMany?: ProdutosDoCardapioCreateManyProdutoInputEnvelope
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
  }

  export type ProdutosDoPedidoCreateNestedManyWithoutProdutoInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutProdutoInput, ProdutosDoPedidoUncheckedCreateWithoutProdutoInput> | ProdutosDoPedidoCreateWithoutProdutoInput[] | ProdutosDoPedidoUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutProdutoInput | ProdutosDoPedidoCreateOrConnectWithoutProdutoInput[]
    createMany?: ProdutosDoPedidoCreateManyProdutoInputEnvelope
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
  }

  export type CategoriaProdutoCreateNestedOneWithoutProdutoInput = {
    create?: XOR<CategoriaProdutoCreateWithoutProdutoInput, CategoriaProdutoUncheckedCreateWithoutProdutoInput>
    connectOrCreate?: CategoriaProdutoCreateOrConnectWithoutProdutoInput
    connect?: CategoriaProdutoWhereUniqueInput
  }

  export type ProdutosDoCardapioUncheckedCreateNestedManyWithoutProdutoInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutProdutoInput, ProdutosDoCardapioUncheckedCreateWithoutProdutoInput> | ProdutosDoCardapioCreateWithoutProdutoInput[] | ProdutosDoCardapioUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutProdutoInput | ProdutosDoCardapioCreateOrConnectWithoutProdutoInput[]
    createMany?: ProdutosDoCardapioCreateManyProdutoInputEnvelope
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
  }

  export type ProdutosDoPedidoUncheckedCreateNestedManyWithoutProdutoInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutProdutoInput, ProdutosDoPedidoUncheckedCreateWithoutProdutoInput> | ProdutosDoPedidoCreateWithoutProdutoInput[] | ProdutosDoPedidoUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutProdutoInput | ProdutosDoPedidoCreateOrConnectWithoutProdutoInput[]
    createMany?: ProdutosDoPedidoCreateManyProdutoInputEnvelope
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
  }

  export type ProdutosDoCardapioUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutProdutoInput, ProdutosDoCardapioUncheckedCreateWithoutProdutoInput> | ProdutosDoCardapioCreateWithoutProdutoInput[] | ProdutosDoCardapioUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutProdutoInput | ProdutosDoCardapioCreateOrConnectWithoutProdutoInput[]
    upsert?: ProdutosDoCardapioUpsertWithWhereUniqueWithoutProdutoInput | ProdutosDoCardapioUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: ProdutosDoCardapioCreateManyProdutoInputEnvelope
    set?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    disconnect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    delete?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    update?: ProdutosDoCardapioUpdateWithWhereUniqueWithoutProdutoInput | ProdutosDoCardapioUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: ProdutosDoCardapioUpdateManyWithWhereWithoutProdutoInput | ProdutosDoCardapioUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: ProdutosDoCardapioScalarWhereInput | ProdutosDoCardapioScalarWhereInput[]
  }

  export type ProdutosDoPedidoUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutProdutoInput, ProdutosDoPedidoUncheckedCreateWithoutProdutoInput> | ProdutosDoPedidoCreateWithoutProdutoInput[] | ProdutosDoPedidoUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutProdutoInput | ProdutosDoPedidoCreateOrConnectWithoutProdutoInput[]
    upsert?: ProdutosDoPedidoUpsertWithWhereUniqueWithoutProdutoInput | ProdutosDoPedidoUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: ProdutosDoPedidoCreateManyProdutoInputEnvelope
    set?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    disconnect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    delete?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    update?: ProdutosDoPedidoUpdateWithWhereUniqueWithoutProdutoInput | ProdutosDoPedidoUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: ProdutosDoPedidoUpdateManyWithWhereWithoutProdutoInput | ProdutosDoPedidoUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: ProdutosDoPedidoScalarWhereInput | ProdutosDoPedidoScalarWhereInput[]
  }

  export type CategoriaProdutoUpdateOneRequiredWithoutProdutoNestedInput = {
    create?: XOR<CategoriaProdutoCreateWithoutProdutoInput, CategoriaProdutoUncheckedCreateWithoutProdutoInput>
    connectOrCreate?: CategoriaProdutoCreateOrConnectWithoutProdutoInput
    upsert?: CategoriaProdutoUpsertWithoutProdutoInput
    connect?: CategoriaProdutoWhereUniqueInput
    update?: XOR<XOR<CategoriaProdutoUpdateToOneWithWhereWithoutProdutoInput, CategoriaProdutoUpdateWithoutProdutoInput>, CategoriaProdutoUncheckedUpdateWithoutProdutoInput>
  }

  export type ProdutosDoCardapioUncheckedUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<ProdutosDoCardapioCreateWithoutProdutoInput, ProdutosDoCardapioUncheckedCreateWithoutProdutoInput> | ProdutosDoCardapioCreateWithoutProdutoInput[] | ProdutosDoCardapioUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoCardapioCreateOrConnectWithoutProdutoInput | ProdutosDoCardapioCreateOrConnectWithoutProdutoInput[]
    upsert?: ProdutosDoCardapioUpsertWithWhereUniqueWithoutProdutoInput | ProdutosDoCardapioUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: ProdutosDoCardapioCreateManyProdutoInputEnvelope
    set?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    disconnect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    delete?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    connect?: ProdutosDoCardapioWhereUniqueInput | ProdutosDoCardapioWhereUniqueInput[]
    update?: ProdutosDoCardapioUpdateWithWhereUniqueWithoutProdutoInput | ProdutosDoCardapioUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: ProdutosDoCardapioUpdateManyWithWhereWithoutProdutoInput | ProdutosDoCardapioUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: ProdutosDoCardapioScalarWhereInput | ProdutosDoCardapioScalarWhereInput[]
  }

  export type ProdutosDoPedidoUncheckedUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<ProdutosDoPedidoCreateWithoutProdutoInput, ProdutosDoPedidoUncheckedCreateWithoutProdutoInput> | ProdutosDoPedidoCreateWithoutProdutoInput[] | ProdutosDoPedidoUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: ProdutosDoPedidoCreateOrConnectWithoutProdutoInput | ProdutosDoPedidoCreateOrConnectWithoutProdutoInput[]
    upsert?: ProdutosDoPedidoUpsertWithWhereUniqueWithoutProdutoInput | ProdutosDoPedidoUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: ProdutosDoPedidoCreateManyProdutoInputEnvelope
    set?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    disconnect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    delete?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    connect?: ProdutosDoPedidoWhereUniqueInput | ProdutosDoPedidoWhereUniqueInput[]
    update?: ProdutosDoPedidoUpdateWithWhereUniqueWithoutProdutoInput | ProdutosDoPedidoUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: ProdutosDoPedidoUpdateManyWithWhereWithoutProdutoInput | ProdutosDoPedidoUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: ProdutosDoPedidoScalarWhereInput | ProdutosDoPedidoScalarWhereInput[]
  }

  export type StatusPagamentoCreateNestedOneWithoutPagamentoInput = {
    create?: XOR<StatusPagamentoCreateWithoutPagamentoInput, StatusPagamentoUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: StatusPagamentoCreateOrConnectWithoutPagamentoInput
    connect?: StatusPagamentoWhereUniqueInput
  }

  export type PedidoCreateNestedOneWithoutPagamentoInput = {
    create?: XOR<PedidoCreateWithoutPagamentoInput, PedidoUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPagamentoInput
    connect?: PedidoWhereUniqueInput
  }

  export type StatusPagamentoUpdateOneRequiredWithoutPagamentoNestedInput = {
    create?: XOR<StatusPagamentoCreateWithoutPagamentoInput, StatusPagamentoUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: StatusPagamentoCreateOrConnectWithoutPagamentoInput
    upsert?: StatusPagamentoUpsertWithoutPagamentoInput
    connect?: StatusPagamentoWhereUniqueInput
    update?: XOR<XOR<StatusPagamentoUpdateToOneWithWhereWithoutPagamentoInput, StatusPagamentoUpdateWithoutPagamentoInput>, StatusPagamentoUncheckedUpdateWithoutPagamentoInput>
  }

  export type PedidoUpdateOneRequiredWithoutPagamentoNestedInput = {
    create?: XOR<PedidoCreateWithoutPagamentoInput, PedidoUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPagamentoInput
    upsert?: PedidoUpsertWithoutPagamentoInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutPagamentoInput, PedidoUpdateWithoutPagamentoInput>, PedidoUncheckedUpdateWithoutPagamentoInput>
  }

  export type ProdutoCreateNestedManyWithoutCategoriaProdutoInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaProdutoInput, ProdutoUncheckedCreateWithoutCategoriaProdutoInput> | ProdutoCreateWithoutCategoriaProdutoInput[] | ProdutoUncheckedCreateWithoutCategoriaProdutoInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaProdutoInput | ProdutoCreateOrConnectWithoutCategoriaProdutoInput[]
    createMany?: ProdutoCreateManyCategoriaProdutoInputEnvelope
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
  }

  export type ProdutoUncheckedCreateNestedManyWithoutCategoriaProdutoInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaProdutoInput, ProdutoUncheckedCreateWithoutCategoriaProdutoInput> | ProdutoCreateWithoutCategoriaProdutoInput[] | ProdutoUncheckedCreateWithoutCategoriaProdutoInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaProdutoInput | ProdutoCreateOrConnectWithoutCategoriaProdutoInput[]
    createMany?: ProdutoCreateManyCategoriaProdutoInputEnvelope
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
  }

  export type ProdutoUpdateManyWithoutCategoriaProdutoNestedInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaProdutoInput, ProdutoUncheckedCreateWithoutCategoriaProdutoInput> | ProdutoCreateWithoutCategoriaProdutoInput[] | ProdutoUncheckedCreateWithoutCategoriaProdutoInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaProdutoInput | ProdutoCreateOrConnectWithoutCategoriaProdutoInput[]
    upsert?: ProdutoUpsertWithWhereUniqueWithoutCategoriaProdutoInput | ProdutoUpsertWithWhereUniqueWithoutCategoriaProdutoInput[]
    createMany?: ProdutoCreateManyCategoriaProdutoInputEnvelope
    set?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    disconnect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    delete?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    update?: ProdutoUpdateWithWhereUniqueWithoutCategoriaProdutoInput | ProdutoUpdateWithWhereUniqueWithoutCategoriaProdutoInput[]
    updateMany?: ProdutoUpdateManyWithWhereWithoutCategoriaProdutoInput | ProdutoUpdateManyWithWhereWithoutCategoriaProdutoInput[]
    deleteMany?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
  }

  export type ProdutoUncheckedUpdateManyWithoutCategoriaProdutoNestedInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaProdutoInput, ProdutoUncheckedCreateWithoutCategoriaProdutoInput> | ProdutoCreateWithoutCategoriaProdutoInput[] | ProdutoUncheckedCreateWithoutCategoriaProdutoInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaProdutoInput | ProdutoCreateOrConnectWithoutCategoriaProdutoInput[]
    upsert?: ProdutoUpsertWithWhereUniqueWithoutCategoriaProdutoInput | ProdutoUpsertWithWhereUniqueWithoutCategoriaProdutoInput[]
    createMany?: ProdutoCreateManyCategoriaProdutoInputEnvelope
    set?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    disconnect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    delete?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    update?: ProdutoUpdateWithWhereUniqueWithoutCategoriaProdutoInput | ProdutoUpdateWithWhereUniqueWithoutCategoriaProdutoInput[]
    updateMany?: ProdutoUpdateManyWithWhereWithoutCategoriaProdutoInput | ProdutoUpdateManyWithWhereWithoutCategoriaProdutoInput[]
    deleteMany?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
  }

  export type ProdutoCreateNestedOneWithoutProdutosDoCardapioInput = {
    create?: XOR<ProdutoCreateWithoutProdutosDoCardapioInput, ProdutoUncheckedCreateWithoutProdutosDoCardapioInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutProdutosDoCardapioInput
    connect?: ProdutoWhereUniqueInput
  }

  export type CardapioCreateNestedOneWithoutProdutosDoCardapioInput = {
    create?: XOR<CardapioCreateWithoutProdutosDoCardapioInput, CardapioUncheckedCreateWithoutProdutosDoCardapioInput>
    connectOrCreate?: CardapioCreateOrConnectWithoutProdutosDoCardapioInput
    connect?: CardapioWhereUniqueInput
  }

  export type ProdutoUpdateOneRequiredWithoutProdutosDoCardapioNestedInput = {
    create?: XOR<ProdutoCreateWithoutProdutosDoCardapioInput, ProdutoUncheckedCreateWithoutProdutosDoCardapioInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutProdutosDoCardapioInput
    upsert?: ProdutoUpsertWithoutProdutosDoCardapioInput
    connect?: ProdutoWhereUniqueInput
    update?: XOR<XOR<ProdutoUpdateToOneWithWhereWithoutProdutosDoCardapioInput, ProdutoUpdateWithoutProdutosDoCardapioInput>, ProdutoUncheckedUpdateWithoutProdutosDoCardapioInput>
  }

  export type CardapioUpdateOneRequiredWithoutProdutosDoCardapioNestedInput = {
    create?: XOR<CardapioCreateWithoutProdutosDoCardapioInput, CardapioUncheckedCreateWithoutProdutosDoCardapioInput>
    connectOrCreate?: CardapioCreateOrConnectWithoutProdutosDoCardapioInput
    upsert?: CardapioUpsertWithoutProdutosDoCardapioInput
    connect?: CardapioWhereUniqueInput
    update?: XOR<XOR<CardapioUpdateToOneWithWhereWithoutProdutosDoCardapioInput, CardapioUpdateWithoutProdutosDoCardapioInput>, CardapioUncheckedUpdateWithoutProdutosDoCardapioInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UsuarioCreateWithoutClienteInput = {
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funcionario?: FuncionarioCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutClienteInput = {
    id?: number
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funcionario?: FuncionarioUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutClienteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
  }

  export type PedidoCreateWithoutClienteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoCreateNestedManyWithoutPedidoInput
    statusPedido: StatusPedidoCreateNestedOneWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutClienteInput = {
    id?: number
    statusPedidoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoCreateManyClienteInputEnvelope = {
    data: PedidoCreateManyClienteInput | PedidoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutClienteInput = {
    update: XOR<UsuarioUpdateWithoutClienteInput, UsuarioUncheckedUpdateWithoutClienteInput>
    create: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutClienteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutClienteInput, UsuarioUncheckedUpdateWithoutClienteInput>
  }

  export type UsuarioUpdateWithoutClienteInput = {
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funcionario?: FuncionarioUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funcionario?: FuncionarioUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type PedidoUpsertWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
  }

  export type PedidoUpdateManyWithWhereWithoutClienteInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutClienteInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    id?: IntFilter<"Pedido"> | number
    clienteId?: IntFilter<"Pedido"> | number
    statusPedidoId?: IntFilter<"Pedido"> | number
    createdAt?: DateTimeFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeFilter<"Pedido"> | Date | string
  }

  export type FuncionarioCreateWithoutUsuarioInput = {
    nome: string
    cargo: string
    admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FuncionarioUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nome: string
    cargo: string
    admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FuncionarioCreateOrConnectWithoutUsuarioInput = {
    where: FuncionarioWhereUniqueInput
    create: XOR<FuncionarioCreateWithoutUsuarioInput, FuncionarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ClienteCreateWithoutUsuarioInput = {
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutUsuarioInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
  }

  export type FuncionarioUpsertWithoutUsuarioInput = {
    update: XOR<FuncionarioUpdateWithoutUsuarioInput, FuncionarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<FuncionarioCreateWithoutUsuarioInput, FuncionarioUncheckedCreateWithoutUsuarioInput>
    where?: FuncionarioWhereInput
  }

  export type FuncionarioUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: FuncionarioWhereInput
    data: XOR<FuncionarioUpdateWithoutUsuarioInput, FuncionarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type FuncionarioUpdateWithoutUsuarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FuncionarioUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUpsertWithoutUsuarioInput = {
    update: XOR<ClienteUpdateWithoutUsuarioInput, ClienteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutUsuarioInput, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ClienteUpdateWithoutUsuarioInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type UsuarioCreateWithoutFuncionarioInput = {
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutFuncionarioInput = {
    id?: number
    tipoAcesso: string
    login: string
    senha: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutFuncionarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFuncionarioInput, UsuarioUncheckedCreateWithoutFuncionarioInput>
  }

  export type UsuarioUpsertWithoutFuncionarioInput = {
    update: XOR<UsuarioUpdateWithoutFuncionarioInput, UsuarioUncheckedUpdateWithoutFuncionarioInput>
    create: XOR<UsuarioCreateWithoutFuncionarioInput, UsuarioUncheckedCreateWithoutFuncionarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutFuncionarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutFuncionarioInput, UsuarioUncheckedUpdateWithoutFuncionarioInput>
  }

  export type UsuarioUpdateWithoutFuncionarioInput = {
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFuncionarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAcesso?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type ClienteCreateWithoutPedidoInput = {
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutPedidoInput = {
    id?: number
    usuarioId: number
    nome?: string | null
    email: string
    cpf: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteCreateOrConnectWithoutPedidoInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutPedidoInput, ClienteUncheckedCreateWithoutPedidoInput>
  }

  export type PagamentoCreateWithoutPedidoInput = {
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    statusPagamento: StatusPagamentoCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUncheckedCreateWithoutPedidoInput = {
    id?: number
    statusPagamentoId: number
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutPedidoInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutPedidoInput, PagamentoUncheckedCreateWithoutPedidoInput>
  }

  export type PagamentoCreateManyPedidoInputEnvelope = {
    data: PagamentoCreateManyPedidoInput | PagamentoCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type StatusPedidoCreateWithoutPedidoInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPedidoUncheckedCreateWithoutPedidoInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPedidoCreateOrConnectWithoutPedidoInput = {
    where: StatusPedidoWhereUniqueInput
    create: XOR<StatusPedidoCreateWithoutPedidoInput, StatusPedidoUncheckedCreateWithoutPedidoInput>
  }

  export type ProdutosDoPedidoCreateWithoutPedidoInput = {
    id?: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produto: ProdutoCreateNestedOneWithoutProdutosDoPedidoInput
  }

  export type ProdutosDoPedidoUncheckedCreateWithoutPedidoInput = {
    id?: number
    produtoId: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoPedidoCreateOrConnectWithoutPedidoInput = {
    where: ProdutosDoPedidoWhereUniqueInput
    create: XOR<ProdutosDoPedidoCreateWithoutPedidoInput, ProdutosDoPedidoUncheckedCreateWithoutPedidoInput>
  }

  export type ProdutosDoPedidoCreateManyPedidoInputEnvelope = {
    data: ProdutosDoPedidoCreateManyPedidoInput | ProdutosDoPedidoCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithoutPedidoInput = {
    update: XOR<ClienteUpdateWithoutPedidoInput, ClienteUncheckedUpdateWithoutPedidoInput>
    create: XOR<ClienteCreateWithoutPedidoInput, ClienteUncheckedCreateWithoutPedidoInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutPedidoInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutPedidoInput, ClienteUncheckedUpdateWithoutPedidoInput>
  }

  export type ClienteUpdateWithoutPedidoInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutPedidoInput, PagamentoUncheckedUpdateWithoutPedidoInput>
    create: XOR<PagamentoCreateWithoutPedidoInput, PagamentoUncheckedCreateWithoutPedidoInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutPedidoInput, PagamentoUncheckedUpdateWithoutPedidoInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutPedidoInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutPedidoInput>
  }

  export type PagamentoScalarWhereInput = {
    AND?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    OR?: PagamentoScalarWhereInput[]
    NOT?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    statusPagamentoId?: IntFilter<"Pagamento"> | number
    pedidoId?: IntFilter<"Pagamento"> | number
    tipo?: StringFilter<"Pagamento"> | string
    data?: DateTimeFilter<"Pagamento"> | Date | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
  }

  export type StatusPedidoUpsertWithoutPedidoInput = {
    update: XOR<StatusPedidoUpdateWithoutPedidoInput, StatusPedidoUncheckedUpdateWithoutPedidoInput>
    create: XOR<StatusPedidoCreateWithoutPedidoInput, StatusPedidoUncheckedCreateWithoutPedidoInput>
    where?: StatusPedidoWhereInput
  }

  export type StatusPedidoUpdateToOneWithWhereWithoutPedidoInput = {
    where?: StatusPedidoWhereInput
    data: XOR<StatusPedidoUpdateWithoutPedidoInput, StatusPedidoUncheckedUpdateWithoutPedidoInput>
  }

  export type StatusPedidoUpdateWithoutPedidoInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPedidoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: ProdutosDoPedidoWhereUniqueInput
    update: XOR<ProdutosDoPedidoUpdateWithoutPedidoInput, ProdutosDoPedidoUncheckedUpdateWithoutPedidoInput>
    create: XOR<ProdutosDoPedidoCreateWithoutPedidoInput, ProdutosDoPedidoUncheckedCreateWithoutPedidoInput>
  }

  export type ProdutosDoPedidoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: ProdutosDoPedidoWhereUniqueInput
    data: XOR<ProdutosDoPedidoUpdateWithoutPedidoInput, ProdutosDoPedidoUncheckedUpdateWithoutPedidoInput>
  }

  export type ProdutosDoPedidoUpdateManyWithWhereWithoutPedidoInput = {
    where: ProdutosDoPedidoScalarWhereInput
    data: XOR<ProdutosDoPedidoUpdateManyMutationInput, ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoInput>
  }

  export type ProdutosDoPedidoScalarWhereInput = {
    AND?: ProdutosDoPedidoScalarWhereInput | ProdutosDoPedidoScalarWhereInput[]
    OR?: ProdutosDoPedidoScalarWhereInput[]
    NOT?: ProdutosDoPedidoScalarWhereInput | ProdutosDoPedidoScalarWhereInput[]
    id?: IntFilter<"ProdutosDoPedido"> | number
    produtoId?: IntFilter<"ProdutosDoPedido"> | number
    pedidoId?: IntFilter<"ProdutosDoPedido"> | number
    quantidade?: IntFilter<"ProdutosDoPedido"> | number
    valor?: DecimalFilter<"ProdutosDoPedido"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ProdutosDoPedido"> | Date | string
    updatedAt?: DateTimeFilter<"ProdutosDoPedido"> | Date | string
  }

  export type PedidoCreateWithoutStatusPedidoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidoInput
    pagamento?: PagamentoCreateNestedManyWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutStatusPedidoInput = {
    id?: number
    clienteId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutStatusPedidoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutStatusPedidoInput, PedidoUncheckedCreateWithoutStatusPedidoInput>
  }

  export type PedidoCreateManyStatusPedidoInputEnvelope = {
    data: PedidoCreateManyStatusPedidoInput | PedidoCreateManyStatusPedidoInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutStatusPedidoInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutStatusPedidoInput, PedidoUncheckedUpdateWithoutStatusPedidoInput>
    create: XOR<PedidoCreateWithoutStatusPedidoInput, PedidoUncheckedCreateWithoutStatusPedidoInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutStatusPedidoInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutStatusPedidoInput, PedidoUncheckedUpdateWithoutStatusPedidoInput>
  }

  export type PedidoUpdateManyWithWhereWithoutStatusPedidoInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutStatusPedidoInput>
  }

  export type PagamentoCreateWithoutStatusPagamentoInput = {
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUncheckedCreateWithoutStatusPagamentoInput = {
    id?: number
    pedidoId: number
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutStatusPagamentoInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutStatusPagamentoInput, PagamentoUncheckedCreateWithoutStatusPagamentoInput>
  }

  export type PagamentoCreateManyStatusPagamentoInputEnvelope = {
    data: PagamentoCreateManyStatusPagamentoInput | PagamentoCreateManyStatusPagamentoInput[]
    skipDuplicates?: boolean
  }

  export type PagamentoUpsertWithWhereUniqueWithoutStatusPagamentoInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutStatusPagamentoInput, PagamentoUncheckedUpdateWithoutStatusPagamentoInput>
    create: XOR<PagamentoCreateWithoutStatusPagamentoInput, PagamentoUncheckedCreateWithoutStatusPagamentoInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutStatusPagamentoInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutStatusPagamentoInput, PagamentoUncheckedUpdateWithoutStatusPagamentoInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutStatusPagamentoInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutStatusPagamentoInput>
  }

  export type ProdutosDoCardapioCreateWithoutCardapioInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produto: ProdutoCreateNestedOneWithoutProdutosDoCardapioInput
  }

  export type ProdutosDoCardapioUncheckedCreateWithoutCardapioInput = {
    id?: number
    produtoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoCardapioCreateOrConnectWithoutCardapioInput = {
    where: ProdutosDoCardapioWhereUniqueInput
    create: XOR<ProdutosDoCardapioCreateWithoutCardapioInput, ProdutosDoCardapioUncheckedCreateWithoutCardapioInput>
  }

  export type ProdutosDoCardapioCreateManyCardapioInputEnvelope = {
    data: ProdutosDoCardapioCreateManyCardapioInput | ProdutosDoCardapioCreateManyCardapioInput[]
    skipDuplicates?: boolean
  }

  export type ProdutosDoCardapioUpsertWithWhereUniqueWithoutCardapioInput = {
    where: ProdutosDoCardapioWhereUniqueInput
    update: XOR<ProdutosDoCardapioUpdateWithoutCardapioInput, ProdutosDoCardapioUncheckedUpdateWithoutCardapioInput>
    create: XOR<ProdutosDoCardapioCreateWithoutCardapioInput, ProdutosDoCardapioUncheckedCreateWithoutCardapioInput>
  }

  export type ProdutosDoCardapioUpdateWithWhereUniqueWithoutCardapioInput = {
    where: ProdutosDoCardapioWhereUniqueInput
    data: XOR<ProdutosDoCardapioUpdateWithoutCardapioInput, ProdutosDoCardapioUncheckedUpdateWithoutCardapioInput>
  }

  export type ProdutosDoCardapioUpdateManyWithWhereWithoutCardapioInput = {
    where: ProdutosDoCardapioScalarWhereInput
    data: XOR<ProdutosDoCardapioUpdateManyMutationInput, ProdutosDoCardapioUncheckedUpdateManyWithoutCardapioInput>
  }

  export type ProdutosDoCardapioScalarWhereInput = {
    AND?: ProdutosDoCardapioScalarWhereInput | ProdutosDoCardapioScalarWhereInput[]
    OR?: ProdutosDoCardapioScalarWhereInput[]
    NOT?: ProdutosDoCardapioScalarWhereInput | ProdutosDoCardapioScalarWhereInput[]
    id?: IntFilter<"ProdutosDoCardapio"> | number
    produtoId?: IntFilter<"ProdutosDoCardapio"> | number
    cardapioId?: IntFilter<"ProdutosDoCardapio"> | number
    createdAt?: DateTimeFilter<"ProdutosDoCardapio"> | Date | string
    updatedAt?: DateTimeFilter<"ProdutosDoCardapio"> | Date | string
  }

  export type ProdutoCreateWithoutProdutosDoPedidoInput = {
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioCreateNestedManyWithoutProdutoInput
    categoriaProduto: CategoriaProdutoCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutProdutosDoPedidoInput = {
    id?: number
    categoriaProdutoId: number
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutProdutosDoPedidoInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutProdutosDoPedidoInput, ProdutoUncheckedCreateWithoutProdutosDoPedidoInput>
  }

  export type PedidoCreateWithoutProdutosDoPedidoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidoInput
    pagamento?: PagamentoCreateNestedManyWithoutPedidoInput
    statusPedido: StatusPedidoCreateNestedOneWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutProdutosDoPedidoInput = {
    id?: number
    clienteId: number
    statusPedidoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pagamento?: PagamentoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutProdutosDoPedidoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutProdutosDoPedidoInput, PedidoUncheckedCreateWithoutProdutosDoPedidoInput>
  }

  export type ProdutoUpsertWithoutProdutosDoPedidoInput = {
    update: XOR<ProdutoUpdateWithoutProdutosDoPedidoInput, ProdutoUncheckedUpdateWithoutProdutosDoPedidoInput>
    create: XOR<ProdutoCreateWithoutProdutosDoPedidoInput, ProdutoUncheckedCreateWithoutProdutosDoPedidoInput>
    where?: ProdutoWhereInput
  }

  export type ProdutoUpdateToOneWithWhereWithoutProdutosDoPedidoInput = {
    where?: ProdutoWhereInput
    data: XOR<ProdutoUpdateWithoutProdutosDoPedidoInput, ProdutoUncheckedUpdateWithoutProdutosDoPedidoInput>
  }

  export type ProdutoUpdateWithoutProdutosDoPedidoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUpdateManyWithoutProdutoNestedInput
    categoriaProduto?: CategoriaProdutoUpdateOneRequiredWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutProdutosDoPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoriaProdutoId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type PedidoUpsertWithoutProdutosDoPedidoInput = {
    update: XOR<PedidoUpdateWithoutProdutosDoPedidoInput, PedidoUncheckedUpdateWithoutProdutosDoPedidoInput>
    create: XOR<PedidoCreateWithoutProdutosDoPedidoInput, PedidoUncheckedCreateWithoutProdutosDoPedidoInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutProdutosDoPedidoInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutProdutosDoPedidoInput, PedidoUncheckedUpdateWithoutProdutosDoPedidoInput>
  }

  export type PedidoUpdateWithoutProdutosDoPedidoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidoNestedInput
    pagamento?: PagamentoUpdateManyWithoutPedidoNestedInput
    statusPedido?: StatusPedidoUpdateOneRequiredWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutProdutosDoPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    statusPedidoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProdutosDoCardapioCreateWithoutProdutoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cardapio: CardapioCreateNestedOneWithoutProdutosDoCardapioInput
  }

  export type ProdutosDoCardapioUncheckedCreateWithoutProdutoInput = {
    id?: number
    cardapioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoCardapioCreateOrConnectWithoutProdutoInput = {
    where: ProdutosDoCardapioWhereUniqueInput
    create: XOR<ProdutosDoCardapioCreateWithoutProdutoInput, ProdutosDoCardapioUncheckedCreateWithoutProdutoInput>
  }

  export type ProdutosDoCardapioCreateManyProdutoInputEnvelope = {
    data: ProdutosDoCardapioCreateManyProdutoInput | ProdutosDoCardapioCreateManyProdutoInput[]
    skipDuplicates?: boolean
  }

  export type ProdutosDoPedidoCreateWithoutProdutoInput = {
    id?: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutProdutosDoPedidoInput
  }

  export type ProdutosDoPedidoUncheckedCreateWithoutProdutoInput = {
    id?: number
    pedidoId: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoPedidoCreateOrConnectWithoutProdutoInput = {
    where: ProdutosDoPedidoWhereUniqueInput
    create: XOR<ProdutosDoPedidoCreateWithoutProdutoInput, ProdutosDoPedidoUncheckedCreateWithoutProdutoInput>
  }

  export type ProdutosDoPedidoCreateManyProdutoInputEnvelope = {
    data: ProdutosDoPedidoCreateManyProdutoInput | ProdutosDoPedidoCreateManyProdutoInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaProdutoCreateWithoutProdutoInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaProdutoUncheckedCreateWithoutProdutoInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaProdutoCreateOrConnectWithoutProdutoInput = {
    where: CategoriaProdutoWhereUniqueInput
    create: XOR<CategoriaProdutoCreateWithoutProdutoInput, CategoriaProdutoUncheckedCreateWithoutProdutoInput>
  }

  export type ProdutosDoCardapioUpsertWithWhereUniqueWithoutProdutoInput = {
    where: ProdutosDoCardapioWhereUniqueInput
    update: XOR<ProdutosDoCardapioUpdateWithoutProdutoInput, ProdutosDoCardapioUncheckedUpdateWithoutProdutoInput>
    create: XOR<ProdutosDoCardapioCreateWithoutProdutoInput, ProdutosDoCardapioUncheckedCreateWithoutProdutoInput>
  }

  export type ProdutosDoCardapioUpdateWithWhereUniqueWithoutProdutoInput = {
    where: ProdutosDoCardapioWhereUniqueInput
    data: XOR<ProdutosDoCardapioUpdateWithoutProdutoInput, ProdutosDoCardapioUncheckedUpdateWithoutProdutoInput>
  }

  export type ProdutosDoCardapioUpdateManyWithWhereWithoutProdutoInput = {
    where: ProdutosDoCardapioScalarWhereInput
    data: XOR<ProdutosDoCardapioUpdateManyMutationInput, ProdutosDoCardapioUncheckedUpdateManyWithoutProdutoInput>
  }

  export type ProdutosDoPedidoUpsertWithWhereUniqueWithoutProdutoInput = {
    where: ProdutosDoPedidoWhereUniqueInput
    update: XOR<ProdutosDoPedidoUpdateWithoutProdutoInput, ProdutosDoPedidoUncheckedUpdateWithoutProdutoInput>
    create: XOR<ProdutosDoPedidoCreateWithoutProdutoInput, ProdutosDoPedidoUncheckedCreateWithoutProdutoInput>
  }

  export type ProdutosDoPedidoUpdateWithWhereUniqueWithoutProdutoInput = {
    where: ProdutosDoPedidoWhereUniqueInput
    data: XOR<ProdutosDoPedidoUpdateWithoutProdutoInput, ProdutosDoPedidoUncheckedUpdateWithoutProdutoInput>
  }

  export type ProdutosDoPedidoUpdateManyWithWhereWithoutProdutoInput = {
    where: ProdutosDoPedidoScalarWhereInput
    data: XOR<ProdutosDoPedidoUpdateManyMutationInput, ProdutosDoPedidoUncheckedUpdateManyWithoutProdutoInput>
  }

  export type CategoriaProdutoUpsertWithoutProdutoInput = {
    update: XOR<CategoriaProdutoUpdateWithoutProdutoInput, CategoriaProdutoUncheckedUpdateWithoutProdutoInput>
    create: XOR<CategoriaProdutoCreateWithoutProdutoInput, CategoriaProdutoUncheckedCreateWithoutProdutoInput>
    where?: CategoriaProdutoWhereInput
  }

  export type CategoriaProdutoUpdateToOneWithWhereWithoutProdutoInput = {
    where?: CategoriaProdutoWhereInput
    data: XOR<CategoriaProdutoUpdateWithoutProdutoInput, CategoriaProdutoUncheckedUpdateWithoutProdutoInput>
  }

  export type CategoriaProdutoUpdateWithoutProdutoInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaProdutoUncheckedUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPagamentoCreateWithoutPagamentoInput = {
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPagamentoUncheckedCreateWithoutPagamentoInput = {
    id?: number
    enumerador: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPagamentoCreateOrConnectWithoutPagamentoInput = {
    where: StatusPagamentoWhereUniqueInput
    create: XOR<StatusPagamentoCreateWithoutPagamentoInput, StatusPagamentoUncheckedCreateWithoutPagamentoInput>
  }

  export type PedidoCreateWithoutPagamentoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidoInput
    statusPedido: StatusPedidoCreateNestedOneWithoutPedidoInput
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutPagamentoInput = {
    id?: number
    clienteId: number
    statusPedidoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutPagamentoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutPagamentoInput, PedidoUncheckedCreateWithoutPagamentoInput>
  }

  export type StatusPagamentoUpsertWithoutPagamentoInput = {
    update: XOR<StatusPagamentoUpdateWithoutPagamentoInput, StatusPagamentoUncheckedUpdateWithoutPagamentoInput>
    create: XOR<StatusPagamentoCreateWithoutPagamentoInput, StatusPagamentoUncheckedCreateWithoutPagamentoInput>
    where?: StatusPagamentoWhereInput
  }

  export type StatusPagamentoUpdateToOneWithWhereWithoutPagamentoInput = {
    where?: StatusPagamentoWhereInput
    data: XOR<StatusPagamentoUpdateWithoutPagamentoInput, StatusPagamentoUncheckedUpdateWithoutPagamentoInput>
  }

  export type StatusPagamentoUpdateWithoutPagamentoInput = {
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPagamentoUncheckedUpdateWithoutPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    enumerador?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUpsertWithoutPagamentoInput = {
    update: XOR<PedidoUpdateWithoutPagamentoInput, PedidoUncheckedUpdateWithoutPagamentoInput>
    create: XOR<PedidoCreateWithoutPagamentoInput, PedidoUncheckedCreateWithoutPagamentoInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutPagamentoInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutPagamentoInput, PedidoUncheckedUpdateWithoutPagamentoInput>
  }

  export type PedidoUpdateWithoutPagamentoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidoNestedInput
    statusPedido?: StatusPedidoUpdateOneRequiredWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    statusPedidoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProdutoCreateWithoutCategoriaProdutoInput = {
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioCreateNestedManyWithoutProdutoInput
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutCategoriaProdutoInput = {
    id?: number
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedCreateNestedManyWithoutProdutoInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutCategoriaProdutoInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutCategoriaProdutoInput, ProdutoUncheckedCreateWithoutCategoriaProdutoInput>
  }

  export type ProdutoCreateManyCategoriaProdutoInputEnvelope = {
    data: ProdutoCreateManyCategoriaProdutoInput | ProdutoCreateManyCategoriaProdutoInput[]
    skipDuplicates?: boolean
  }

  export type ProdutoUpsertWithWhereUniqueWithoutCategoriaProdutoInput = {
    where: ProdutoWhereUniqueInput
    update: XOR<ProdutoUpdateWithoutCategoriaProdutoInput, ProdutoUncheckedUpdateWithoutCategoriaProdutoInput>
    create: XOR<ProdutoCreateWithoutCategoriaProdutoInput, ProdutoUncheckedCreateWithoutCategoriaProdutoInput>
  }

  export type ProdutoUpdateWithWhereUniqueWithoutCategoriaProdutoInput = {
    where: ProdutoWhereUniqueInput
    data: XOR<ProdutoUpdateWithoutCategoriaProdutoInput, ProdutoUncheckedUpdateWithoutCategoriaProdutoInput>
  }

  export type ProdutoUpdateManyWithWhereWithoutCategoriaProdutoInput = {
    where: ProdutoScalarWhereInput
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyWithoutCategoriaProdutoInput>
  }

  export type ProdutoScalarWhereInput = {
    AND?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
    OR?: ProdutoScalarWhereInput[]
    NOT?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
    id?: IntFilter<"Produto"> | number
    categoriaProdutoId?: IntFilter<"Produto"> | number
    descricao?: StringFilter<"Produto"> | string
    preco?: DecimalFilter<"Produto"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Produto"> | Date | string
    updatedAt?: DateTimeFilter<"Produto"> | Date | string
  }

  export type ProdutoCreateWithoutProdutosDoCardapioInput = {
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProdutosDoPedido?: ProdutosDoPedidoCreateNestedManyWithoutProdutoInput
    categoriaProduto: CategoriaProdutoCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutProdutosDoCardapioInput = {
    id?: number
    categoriaProdutoId: number
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutProdutosDoCardapioInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutProdutosDoCardapioInput, ProdutoUncheckedCreateWithoutProdutosDoCardapioInput>
  }

  export type CardapioCreateWithoutProdutosDoCardapioInput = {
    descricao: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardapioUncheckedCreateWithoutProdutosDoCardapioInput = {
    id?: number
    descricao: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardapioCreateOrConnectWithoutProdutosDoCardapioInput = {
    where: CardapioWhereUniqueInput
    create: XOR<CardapioCreateWithoutProdutosDoCardapioInput, CardapioUncheckedCreateWithoutProdutosDoCardapioInput>
  }

  export type ProdutoUpsertWithoutProdutosDoCardapioInput = {
    update: XOR<ProdutoUpdateWithoutProdutosDoCardapioInput, ProdutoUncheckedUpdateWithoutProdutosDoCardapioInput>
    create: XOR<ProdutoCreateWithoutProdutosDoCardapioInput, ProdutoUncheckedCreateWithoutProdutosDoCardapioInput>
    where?: ProdutoWhereInput
  }

  export type ProdutoUpdateToOneWithWhereWithoutProdutosDoCardapioInput = {
    where?: ProdutoWhereInput
    data: XOR<ProdutoUpdateWithoutProdutosDoCardapioInput, ProdutoUncheckedUpdateWithoutProdutosDoCardapioInput>
  }

  export type ProdutoUpdateWithoutProdutosDoCardapioInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutProdutoNestedInput
    categoriaProduto?: CategoriaProdutoUpdateOneRequiredWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutProdutosDoCardapioInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoriaProdutoId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type CardapioUpsertWithoutProdutosDoCardapioInput = {
    update: XOR<CardapioUpdateWithoutProdutosDoCardapioInput, CardapioUncheckedUpdateWithoutProdutosDoCardapioInput>
    create: XOR<CardapioCreateWithoutProdutosDoCardapioInput, CardapioUncheckedCreateWithoutProdutosDoCardapioInput>
    where?: CardapioWhereInput
  }

  export type CardapioUpdateToOneWithWhereWithoutProdutosDoCardapioInput = {
    where?: CardapioWhereInput
    data: XOR<CardapioUpdateWithoutProdutosDoCardapioInput, CardapioUncheckedUpdateWithoutProdutosDoCardapioInput>
  }

  export type CardapioUpdateWithoutProdutosDoCardapioInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardapioUncheckedUpdateWithoutProdutosDoCardapioInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyClienteInput = {
    id?: number
    statusPedidoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutClienteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUpdateManyWithoutPedidoNestedInput
    statusPedido?: StatusPedidoUpdateOneRequiredWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusPedidoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUncheckedUpdateManyWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusPedidoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyPedidoInput = {
    id?: number
    statusPagamentoId: number
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoPedidoCreateManyPedidoInput = {
    id?: number
    produtoId: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUpdateWithoutPedidoInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusPagamento?: StatusPagamentoUpdateOneRequiredWithoutPagamentoNestedInput
  }

  export type PagamentoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusPagamentoId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusPagamentoId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produto?: ProdutoUpdateOneRequiredWithoutProdutosDoPedidoNestedInput
  }

  export type ProdutosDoPedidoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyStatusPedidoInput = {
    id?: number
    clienteId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutStatusPedidoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidoNestedInput
    pagamento?: PagamentoUpdateManyWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutStatusPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUncheckedUpdateManyWithoutPedidoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutStatusPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyStatusPagamentoInput = {
    id?: number
    pedidoId: number
    tipo: string
    data: Date | string
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagamentoUpdateWithoutStatusPagamentoInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutPagamentoNestedInput
  }

  export type PagamentoUncheckedUpdateWithoutStatusPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyWithoutStatusPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioCreateManyCardapioInput = {
    id?: number
    produtoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoCardapioUpdateWithoutCardapioInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produto?: ProdutoUpdateOneRequiredWithoutProdutosDoCardapioNestedInput
  }

  export type ProdutosDoCardapioUncheckedUpdateWithoutCardapioInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioUncheckedUpdateManyWithoutCardapioInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioCreateManyProdutoInput = {
    id?: number
    cardapioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoPedidoCreateManyProdutoInput = {
    id?: number
    pedidoId: number
    quantidade: number
    valor: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutosDoCardapioUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cardapio?: CardapioUpdateOneRequiredWithoutProdutosDoCardapioNestedInput
  }

  export type ProdutosDoCardapioUncheckedUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardapioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoCardapioUncheckedUpdateManyWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cardapioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutProdutosDoPedidoNestedInput
  }

  export type ProdutosDoPedidoUncheckedUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutosDoPedidoUncheckedUpdateManyWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProdutoCreateManyCategoriaProdutoInput = {
    id?: number
    descricao: string
    preco: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProdutoUpdateWithoutCategoriaProdutoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUpdateManyWithoutProdutoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutCategoriaProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produtosDoCardapio?: ProdutosDoCardapioUncheckedUpdateManyWithoutProdutoNestedInput
    ProdutosDoPedido?: ProdutosDoPedidoUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateManyWithoutCategoriaProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoCountOutputTypeDefaultArgs instead
     */
    export type PedidoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusPedidoCountOutputTypeDefaultArgs instead
     */
    export type StatusPedidoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusPedidoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusPagamentoCountOutputTypeDefaultArgs instead
     */
    export type StatusPagamentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusPagamentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardapioCountOutputTypeDefaultArgs instead
     */
    export type CardapioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardapioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutoCountOutputTypeDefaultArgs instead
     */
    export type ProdutoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaProdutoCountOutputTypeDefaultArgs instead
     */
    export type CategoriaProdutoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaProdutoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoAcessoDefaultArgs instead
     */
    export type TipoAcessoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoAcessoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FuncionarioDefaultArgs instead
     */
    export type FuncionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FuncionarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoDefaultArgs instead
     */
    export type PedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusPedidoDefaultArgs instead
     */
    export type StatusPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusPedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusPagamentoDefaultArgs instead
     */
    export type StatusPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusPagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardapioDefaultArgs instead
     */
    export type CardapioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardapioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutosDoPedidoDefaultArgs instead
     */
    export type ProdutosDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutosDoPedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutoDefaultArgs instead
     */
    export type ProdutoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagamentoDefaultArgs instead
     */
    export type PagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaProdutoDefaultArgs instead
     */
    export type CategoriaProdutoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaProdutoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutosDoCardapioDefaultArgs instead
     */
    export type ProdutosDoCardapioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutosDoCardapioDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}